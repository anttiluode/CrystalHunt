<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fused Crystal Hunt: World Mind Edition</title>
    
    <!-- Three.js and MediaPipe -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/simplex-noise/2.4.0/simplex-noise.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/pose/pose.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: linear-gradient(180deg, #87CEEB 0%, #98FB98 20%, #228B22 100%);
            overflow: hidden;
            font-family: 'Courier New', monospace;
            color: #fff;
        }
        
        .container { width: 100vw; height: 100vh; position: relative; }
        
        .startup {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            z-index: 1000;
            background: rgba(0, 0, 0, 0.9);
            padding: 40px;
            border-radius: 20px;
            border: 3px solid #ff44ff;
            backdrop-filter: blur(15px);
        }
        
        .startup h1 {
            font-size: 3.5em;
            margin-bottom: 20px;
            background: linear-gradient(45deg, #ff44ff, #44ffff, #ffff44, #ff4444);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-shadow: 0 0 30px #ff44ff;
        }
        
        .start-btn {
            background: linear-gradient(45deg, #ff0080, #8000ff, #00ff80, #ff8000);
            border: none;
            padding: 20px 40px;
            font-size: 2em;
            color: white;
            cursor: pointer;
            border-radius: 20px;
            font-family: inherit;
            font-weight: bold;
            transition: all 0.3s;
            margin: 20px;
        }
        
        .start-btn:hover {
            transform: scale(1.1);
            box-shadow: 0 0 50px rgba(255, 68, 255, 0.8);
        }
        
        .hidden { display: none !important; }
        
        #worldCanvas { position: absolute; top: 0; left: 0; z-index: 1; }
        
        #webcamFeed {
            position: absolute;
            bottom: 20px; right: 20px;
            width: 200px; height: 130px;
            border: 3px solid #00ffff;
            border-radius: 15px;
            z-index: 100;
            background: #000;
        }
        
        .game-hud {
            position: absolute;
            top: 20px; left: 20px;
            width: 350px;
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid #ff44ff;
            border-radius: 15px;
            padding: 20px;
            z-index: 100;
            backdrop-filter: blur(10px);
        }
        
        .energy-bar {
            width: 100%;
            height: 20px;
            background: #333;
            border-radius: 10px;
            margin: 10px 0;
            overflow: hidden;
        }
        
        .energy-fill {
            height: 100%;
            background: linear-gradient(90deg, #ff0000, #ffff00, #00ff00);
            width: 100%;
            transition: width 0.3s;
            border-radius: 10px;
        }
        
        .crystal-counter {
            font-size: 1.5em;
            color: #ffff44;
            text-shadow: 0 0 10px #ffff44;
            margin: 10px 0;
        }
        
        .game-over {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            z-index: 2000;
            background: rgba(0, 0, 0, 0.95);
            padding: 40px;
            border-radius: 20px;
            border: 3px solid #ff0000;
            backdrop-filter: blur(15px);
        }
        
        .game-over h2 {
            font-size: 3em;
            color: #ff0000;
            margin-bottom: 20px;
            text-shadow: 0 0 20px #ff0000;
        }
        
        .final-score {
            font-size: 1.5em;
            color: #ffff44;
            margin: 20px 0;
        }
        
        .instruction-hint {
            position: absolute;
            bottom: 160px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            padding: 10px 20px;
            border-radius: 10px;
            border: 1px solid #ffff44;
            z-index: 100;
            font-size: 14px;
            text-align: center;
            animation: fadeInOut 3s infinite;
        }
        
        @keyframes fadeInOut {
            0%, 100% { opacity: 0.7; }
            50% { opacity: 1; }
        }
        
        .crystal-indicator {
            position: absolute;
            pointer-events: none;
            z-index: 200;
            color: #ffff44;
            font-size: 24px;
            font-weight: bold;
            text-shadow: 0 0 10px #ffff44;
            animation: collectAnimation 1s ease-out forwards;
        }
        
        @keyframes collectAnimation {
            0% { transform: scale(1) translateY(0); opacity: 1; }
            100% { transform: scale(2) translateY(-50px); opacity: 0; }
        }
        
        .sound-controls {
            position: absolute;
            top: 20px;
            right: 250px;
            z-index: 100;
        }
        
        .sound-btn {
            background: linear-gradient(45deg, #44ff44, #4444ff);
            border: none;
            color: white;
            padding: 10px 15px;
            border-radius: 10px;
            cursor: pointer;
            font-weight: bold;
            margin: 5px;
        }
        
        .sound-btn:hover {
            transform: scale(1.1);
            box-shadow: 0 0 20px rgba(68, 255, 68, 0.6);
        }

        .world-info {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 10px;
            border: 1px solid #44ff44;
            z-index: 100;
            font-size: 12px;
            max-width: 300px;
        }

        .season-indicator {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.8);
            padding: 10px 20px;
            border-radius: 10px;
            border: 1px solid #ffff44;
            z-index: 100;
            font-size: 14px;
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Startup Screen -->
        <div class="startup" id="startup">
            <h1>üèõÔ∏è Crystal Hunt: Civilization World üåç</h1>
            <p style="font-size: 1.2em; margin: 20px 0; color: #ccc;">
                Explore infinite procedural worlds with ancient civilizations!<br>
                Collect crystals, chase rainbow attractors, discover lost cities!<br>
                üéµ Full soundtrack ‚Ä¢ üèõÔ∏è Procedural civilizations ‚Ä¢ üåà Infinite attractors
            </p>
            <button class="start-btn" onclick="startGame()">üöÄ Begin Civilization Hunt üèõÔ∏è</button>
        </div>
        
        <!-- Game Over Screen -->
        <div class="game-over hidden" id="gameOverScreen">
            <h2>Civilization Explored!</h2>
            <div class="final-score" id="finalScore">Artifacts Found: 0</div>
            <button class="start-btn" onclick="restartGame()">üîÑ Explore New World</button>
        </div>
        
        <!-- Game Interface -->
        <div class="hidden" id="gameInterface">
            <canvas id="worldCanvas"></canvas>
            <canvas id="webcamFeed"></canvas>
            
            <!-- Sound Controls -->
            <div class="sound-controls">
                <button class="sound-btn" id="musicBtn" onclick="toggleMusic()">üéµ Music: ON</button>
                <button class="sound-btn" id="sfxBtn" onclick="toggleSFX()">üîä SFX: ON</button>
            </div>
            
            <!-- Season Indicator -->
            <div class="season-indicator">
                <div>üåø Season: <span id="currentSeason">Spring</span></div>
                <div>üïí Time: <span id="currentTime">Dawn</span></div>
            </div>
            
            <!-- Game HUD -->
            <div class="game-hud">
                <div style="color: #ff44ff; font-size: 16px; font-weight: bold; text-align: center; margin-bottom: 15px;">üèõÔ∏è CIVILIZATION HUNT</div>
                <div class="crystal-counter" id="crystalCounter">Artifacts: 0</div>
                <div style="color: #ff44ff; font-size: 12px;">Life Energy:</div>
                <div class="energy-bar">
                    <div class="energy-fill" id="energyFill"></div>
                </div>
                <div style="display: flex; justify-content: space-between; font-size: 12px; margin-top: 10px;">
                    <span>Score: <span id="gameScore" style="color: #ffff44;">0</span></span>
                    <span>Attractors: <span id="attractorCount" style="color: #ff44ff;">0</span></span>
                </div>
                <div style="display: flex; justify-content: space-between; font-size: 12px; margin-top: 5px;">
                    <span>Cities: <span id="cityCount" style="color: #44ffff;">0</span></span>
                    <span>Speed: <span id="currentSpeed" style="color: #fff;">0 km/h</span></span>
                </div>
            </div>
            
            <!-- World Info -->
            <div class="world-info">
                <h4 style="color: #44ff44;">üåç WORLD STATUS</h4>
                <div>Biome: <span id="currentBiome" style="color: #fff;">Temperate Forest</span></div>
                <div>Civilizations Found: <span id="civsFound" style="color: #ffff44;">0</span></div>
                <div>Weather: <span id="currentWeather" style="color: #87CEEB;">Clear</span></div>
                <div>Altitude: <span id="currentAltitude" style="color: #fff;">150m</span></div>
            </div>
            
            <!-- Instruction Hint -->
            <div class="instruction-hint">
                ‚úã Gesture controls: Left hand for speed ‚Ä¢ Right hand to steer ‚Ä¢ Chase the üåà rainbow attractors!
            </div>
        </div>
    </div>

    <script>
        // Global variables
        let gameState = 'menu';
        let crystalsCollected = 0;
        let lifeEnergy = 100;
        let gameScore = 0;
        let gameStartTime = 0;
        let energyDecayRate = 0.6;
        let crystalEnergyBonus = 25;
        let attractorsCaught = 0;
        let citiesFound = 0;
        
        // Flight and world variables
        let scene, camera, renderer;
        let poseDetector, cameraStream, webcamCanvas, webcamCtx;
        let isActive = false;
        let currentPose = null;
        
        let flightSpeed = 0;
        let flightDirection = { x: 0, y: 0, z: 1 };
        let cameraRotation = { x: 0, y: 0, z: 0 };
        let altitude = 150;
        
        // World generation enhanced
        const noise = new SimplexNoise();
        const chunkSize = 400;
        const viewDistance = 3;
        const chunks = new Map();
        const trees = [];
        const cacti = [];
        const crystals = [];
        const civilizations = [];
        const infiniteAttractors = [];
        const volumetricClouds = [];
        let chunksLoaded = 0;
        
        // Season and time system
        let currentSeason = 'spring';
        let timeOfDay = 6; // Start at dawn
        let timeSpeed = 0.02;
        
        // Audio system
        let audioContext;
        let musicEnabled = true;
        let sfxEnabled = true;
        
        // Season colors
        const seasonColors = {
            spring: { sky: 0x87CEEB, foliage: 0x90EE90 },
            summer: { sky: 0x4169E1, foliage: 0x228B22 },
            autumn: { sky: 0xFFA500, foliage: 0xFF4500 },
            winter: { sky: 0x708090, foliage: 0x2F4F4F }
        };
        
        // Helper function for linear interpolation
        Math.lerp = function(a, b, t) {
            return a + t * (b - a);
        };
        
        // Enhanced Crystal class with civilization artifacts
        class CivilizationArtifact {
            constructor(position, type = 'relic') {
                this.position = position.clone();
                this.originalPosition = position.clone();
                this.type = type;
                this.collected = false;
                this.age = 0;
                this.rotationSpeed = Math.random() * 0.015 + 0.008;
                this.bobSpeed = Math.random() * 0.002 + 0.001;
                this.energy = type === 'legendary' ? 50 : type === 'rare' ? 35 : 25;
                this.frequency = 150 + Math.random() * 600;
                this.culturalValue = Math.random() * 100 + 50;
                
                // Create visual representation based on type
                let geometry, material;
                
                if (type === 'legendary') {
                    geometry = new THREE.DodecahedronGeometry(12, 1);
                    material = new THREE.MeshPhongMaterial({
                        color: 0xffd700,
                        transparent: true,
                        opacity: 0.9,
                        emissive: 0x443300
                    });
                } else if (type === 'rare') {
                    geometry = new THREE.OctahedronGeometry(8, 1);
                    material = new THREE.MeshPhongMaterial({
                        color: 0xffa500,
                        transparent: true,
                        opacity: 0.8,
                        emissive: 0x442200
                    });
                } else {
                    geometry = new THREE.TetrahedronGeometry(6, 0);
                    material = new THREE.MeshPhongMaterial({
                        color: 0x44ffff,
                        transparent: true,
                        opacity: 0.7,
                        emissive: 0x002244
                    });
                }
                
                this.mesh = new THREE.Mesh(geometry, material);
                this.mesh.position.copy(this.position);
                this.mesh.castShadow = true;
                scene.add(this.mesh);
                
                // Enhanced glow effect
                const glowGeometry = new THREE.SphereGeometry(type === 'legendary' ? 18 : type === 'rare' ? 12 : 9, 16, 16);
                const glowMaterial = new THREE.MeshBasicMaterial({
                    color: type === 'legendary' ? 0xffd700 : type === 'rare' ? 0xffa500 : 0x44ffff,
                    transparent: true,
                    opacity: 0.15
                });
                this.glowMesh = new THREE.Mesh(glowGeometry, glowMaterial);
                this.glowMesh.position.copy(this.position);
                scene.add(this.glowMesh);
            }
            
            update(deltaTime) {
                if (this.collected) return;
                
                this.age += deltaTime;
                
                // Enhanced floating animation
                this.mesh.rotation.y += this.rotationSpeed;
                this.mesh.rotation.x += this.rotationSpeed * 0.3;
                this.mesh.rotation.z += this.rotationSpeed * 0.2;
                
                const bobOffset = Math.sin(this.age * this.bobSpeed) * 4;
                const circularMotion = Math.cos(this.age * this.bobSpeed * 0.7) * 2;
                this.mesh.position.y = this.originalPosition.y + bobOffset;
                this.mesh.position.x = this.originalPosition.x + circularMotion;
                this.glowMesh.position.copy(this.mesh.position);
                
                // Enhanced pulsing glow
                const glowPulse = (Math.sin(this.age * 0.003) + 1) * 0.5;
                this.glowMesh.material.opacity = 0.05 + glowPulse * 0.25;
                this.mesh.material.emissiveIntensity = 0.2 + glowPulse * 0.3;
                
                // Check for collection
                const distanceToPlayer = this.mesh.position.distanceTo(camera.position);
                if (distanceToPlayer < 18) {
                    this.collect();
                }
            }
            
            collect() {
                if (this.collected) return;
                
                this.collected = true;
                scene.remove(this.mesh);
                scene.remove(this.glowMesh);
                
                // Update game state based on artifact type
                crystalsCollected++;
                lifeEnergy = Math.min(100, lifeEnergy + this.energy);
                
                if (this.type === 'legendary') {
                    gameScore += 500;
                } else if (this.type === 'rare') {
                    gameScore += 200;
                } else {
                    gameScore += 75;
                }
                
                // Play collection sound
                this.playCollectionSound();
                
                // Show collection indicator
                this.showCollectionEffect();
                
                // Update UI
                updateGameUI();
            }
            
            playCollectionSound() {
                if (!audioContext || !sfxEnabled) return;
                
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                // Different sounds for different artifact types
                let baseFreq = this.frequency;
                if (this.type === 'legendary') baseFreq *= 1.5;
                else if (this.type === 'rare') baseFreq *= 1.2;
                
                oscillator.frequency.setValueAtTime(baseFreq, audioContext.currentTime);
                oscillator.frequency.exponentialRampToValueAtTime(baseFreq * 2.5, audioContext.currentTime + 0.4);
                
                gainNode.gain.setValueAtTime(0.15, audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.4);
                
                oscillator.start();
                oscillator.stop(audioContext.currentTime + 0.4);
            }
            
            showCollectionEffect() {
                const indicator = document.createElement('div');
                indicator.className = 'crystal-indicator';
                
                let text = '+75 ‚ö±Ô∏è';
                if (this.type === 'legendary') text = '+500 üèõÔ∏è LEGENDARY!';
                else if (this.type === 'rare') text = '+200 üíé RARE!';
                
                indicator.textContent = text;
                indicator.style.left = '50%';
                indicator.style.top = '40%';
                document.body.appendChild(indicator);
                
                setTimeout(() => indicator.remove(), 1000);
            }
        }
        
        // Infinite Attractor class (rainbow ball that flies around)
        class InfiniteAttractor {
            constructor() {
                this.position = new THREE.Vector3(
                    (Math.random() - 0.5) * 300,
                    50 + Math.random() * 100,
                    (Math.random() - 0.5) * 300
                );
                this.velocity = new THREE.Vector3(
                    (Math.random() - 0.5) * 2,
                    (Math.random() - 0.5) * 0.5,
                    (Math.random() - 0.5) * 2
                );
                this.age = 0;
                this.caught = false;
                this.trailPoints = [];
                this.maxTrailLength = 20;
                
                // Create rainbow sphere
                const geometry = new THREE.SphereGeometry(3, 16, 12);
                const material = new THREE.MeshBasicMaterial({
                    color: 0xffffff,
                    transparent: true,
                    opacity: 0.8
                });
                this.mesh = new THREE.Mesh(geometry, material);
                this.mesh.position.copy(this.position);
                scene.add(this.mesh);
                
                // Create rainbow trail
                this.createTrail();
            }
            
            createTrail() {
                const trailGeometry = new THREE.BufferGeometry();
                const positions = new Float32Array(this.maxTrailLength * 3);
                const colors = new Float32Array(this.maxTrailLength * 3);
                
                trailGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                trailGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
                
                const trailMaterial = new THREE.LineBasicMaterial({
                    vertexColors: true,
                    transparent: true,
                    opacity: 0.6,
                    linewidth: 3
                });
                this.trailMesh = new THREE.Line(trailGeometry, trailMaterial);
                scene.add(this.trailMesh);
            }
            
            update(deltaTime) {
                if (this.caught) return;
                
                this.age += deltaTime;
                
                // Update position with smooth sine wave motion
                this.velocity.x += Math.sin(this.age * 0.01) * 0.02;
                this.velocity.z += Math.cos(this.age * 0.015) * 0.02;
                this.velocity.y += Math.sin(this.age * 0.008) * 0.01;
                
                // Constrain to world bounds and height
                this.velocity.multiplyScalar(0.98);
                this.position.add(this.velocity);
                
                // Keep within bounds (30-200m as requested)
                if (Math.abs(this.position.x) > 200) this.velocity.x *= -1;
                if (Math.abs(this.position.z) > 200) this.velocity.z *= -1;
                if (this.position.y < 30 || this.position.y > 200) this.velocity.y *= -1;
                
                this.mesh.position.copy(this.position);
                
                // Rainbow color cycling
                const hue = (this.age * 0.5) % 1;
                this.mesh.material.color.setHSL(hue, 1, 0.5);
                
                // Update trail
                this.updateTrail();
                
                // Check for collection
                const distanceToPlayer = this.position.distanceTo(camera.position);
                if (distanceToPlayer < 15) {
                    this.catch();
                }
            }
            
            updateTrail() {
                // Add current position to trail
                this.trailPoints.push(this.position.clone());
                if (this.trailPoints.length > this.maxTrailLength) {
                    this.trailPoints.shift();
                }
                
                // Update trail geometry
                const positions = this.trailMesh.geometry.attributes.position.array;
                const colors = this.trailMesh.geometry.attributes.color.array;
                
                for (let i = 0; i < this.trailPoints.length; i++) {
                    const point = this.trailPoints[i];
                    positions[i * 3] = point.x;
                    positions[i * 3 + 1] = point.y;
                    positions[i * 3 + 2] = point.z;
                    
                    // Rainbow colors for trail
                    const hue = ((this.age * 0.5) + i * 0.1) % 1;
                    const color = new THREE.Color().setHSL(hue, 1, 0.5);
                    colors[i * 3] = color.r;
                    colors[i * 3 + 1] = color.g;
                    colors[i * 3 + 2] = color.b;
                }
                
                this.trailMesh.geometry.attributes.position.needsUpdate = true;
                this.trailMesh.geometry.attributes.color.needsUpdate = true;
            }
            
            catch() {
                if (this.caught) return;
                
                this.caught = true;
                scene.remove(this.mesh);
                scene.remove(this.trailMesh);
                
                // Massive score bonus
                attractorsCaught++;
                gameScore += 1000;
                lifeEnergy = Math.min(100, lifeEnergy + 40);
                
                // Play meow sound
                this.playMeowSound();
                
                // Show collection effect
                const indicator = document.createElement('div');
                indicator.className = 'crystal-indicator';
                indicator.textContent = '+1000 üåà RAINBOW CAUGHT!';
                indicator.style.left = '50%';
                indicator.style.top = '40%';
                indicator.style.fontSize = '28px';
                indicator.style.color = '#ff00ff';
                document.body.appendChild(indicator);
                
                setTimeout(() => indicator.remove(), 1500);
                
                updateGameUI();
            }
            
            playMeowSound() {
                if (!audioContext || !sfxEnabled) return;
                
                // Create a meow-like sound using multiple oscillators
                const fundamentalFreq = 200;
                
                for (let i = 0; i < 3; i++) {
                    const oscillator = audioContext.createOscillator();
                    const gainNode = audioContext.createGain();
                    const filter = audioContext.createBiquadFilter();
                    
                    oscillator.connect(filter);
                    filter.connect(gainNode);
                    gainNode.connect(audioContext.destination);
                    
                    oscillator.type = 'triangle';
                    oscillator.frequency.setValueAtTime(fundamentalFreq * (i + 1), audioContext.currentTime);
                    oscillator.frequency.exponentialRampToValueAtTime(fundamentalFreq * (i + 1) * 0.5, audioContext.currentTime + 0.3);
                    
                    filter.type = 'lowpass';
                    filter.frequency.setValueAtTime(2000, audioContext.currentTime);
                    filter.frequency.exponentialRampToValueAtTime(500, audioContext.currentTime + 0.3);
                    
                    gainNode.gain.setValueAtTime(0.1 / (i + 1), audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.3);
                    
                    oscillator.start();
                    oscillator.stop(audioContext.currentTime + 0.3);
                }
            }
        }
        
        // Civilization Structure class
        class CivilizationStructure {
            constructor(x, y, z, type = 'building') {
                this.position = new THREE.Vector3(x, y, z);
                this.type = type;
                this.age = Math.random() * 1000;
                this.culturalSignificance = Math.random();
                
                this.createStructure();
            }
            
            createStructure() {
                const group = new THREE.Group();
                
                // Define local variables from the position
                const x = this.position.x;
                const y = this.position.y;
                const z = this.position.z;
                
                if (this.type === 'temple') {
                    // Create ancient temple
                    const baseGeometry = new THREE.BoxGeometry(15, 8, 15);
                    const baseMaterial = new THREE.MeshLambertMaterial({ color: 0xD2691E });
                    const base = new THREE.Mesh(baseGeometry, baseMaterial);
                    base.position.y = 4;
                    base.castShadow = true;
                    group.add(base);
                    
                    // Add pillars
                    for (let i = 0; i < 8; i++) {
                        const pillarGeometry = new THREE.CylinderGeometry(0.8, 1, 12, 8);
                        const pillarMaterial = new THREE.MeshLambertMaterial({ color: 0xF4A460 });
                        const pillar = new THREE.Mesh(pillarGeometry, pillarMaterial);
                        const angle = (i / 8) * Math.PI * 2;
                        pillar.position.x = Math.cos(angle) * 6;
                        pillar.position.z = Math.sin(angle) * 6;
                        pillar.position.y = 6;
                        pillar.castShadow = true;
                        group.add(pillar);
                    }
                    
                    // Spawn legendary artifact nearby
                    const artifact = new CivilizationArtifact(
                        new THREE.Vector3(x + (Math.random() - 0.5) * 20, y + 5, z + (Math.random() - 0.5) * 20),
                        'legendary'
                    );
                    crystals.push(artifact);
                    
                } else if (this.type === 'pyramid') {
                    // Create pyramid structure
                    const pyramidGeometry = new THREE.ConeGeometry(12, 20, 4);
                    const pyramidMaterial = new THREE.MeshLambertMaterial({ color: 0xCD853F });
                    const pyramid = new THREE.Mesh(pyramidGeometry, pyramidMaterial);
                    pyramid.position.y = 10;
                    pyramid.rotation.y = Math.PI / 4;
                    pyramid.castShadow = true;
                    group.add(pyramid);
                    
                    // Spawn rare artifacts around pyramid
                    for (let i = 0; i < 3; i++) {
                        const artifact = new CivilizationArtifact(
                            new THREE.Vector3(
                                x + (Math.random() - 0.5) * 30,
                                y + 2,
                                z + (Math.random() - 0.5) * 30
                            ),
                            Math.random() < 0.3 ? 'rare' : 'relic'
                        );
                        crystals.push(artifact);
                    }
                    
                } else {
                    // Regular ancient building (now a simple cube)
                    const buildingHeight = 8 + Math.random() * 15;
                    const buildingWidth = 8 + Math.random() * 8;
                    const buildingGeometry = new THREE.BoxGeometry(
                        buildingWidth,
                        buildingHeight,
                        buildingWidth
                    );
                    const buildingMaterial = new THREE.MeshLambertMaterial({
                        color: new THREE.Color().setHSL(0.1, 0.2, 0.4 + Math.random() * 0.1)
                    });
                    const building = new THREE.Mesh(buildingGeometry, buildingMaterial);
                    building.position.y = buildingHeight / 2;
                    building.castShadow = true;
                    group.add(building);
                    
                    // Spawn regular artifacts
                    if (Math.random() < 0.4) {
                        const artifact = new CivilizationArtifact(
                            new THREE.Vector3(
                                x + (Math.random() - 0.5) * 15,
                                y + 2,
                                z + (Math.random() - 0.5) * 15
                            ),
                            'relic'
                        );
                        crystals.push(artifact);
                    }
                }
                
                group.position.copy(this.position);
                scene.add(group);
                this.mesh = group;
            }
        }
        
        // Enhanced 3D Cloud system
        class VolumetricCloud {
            constructor(x, y, z) {
                this.position = new THREE.Vector3(x, y, z);
                this.velocity = new THREE.Vector3(
                    (Math.random() - 0.5) * 0.5,
                    0,
                    (Math.random() - 0.5) * 0.3
                );
                this.age = 0;
                this.opacity = 0.3 + Math.random() * 0.4;
                this.scale = 0.8 + Math.random() * 0.6;
                
                this.createCloud();
            }
            
            createCloud() {
                const group = new THREE.Group();
                const numPuffs = 8 + Math.floor(Math.random() * 12);
                
                for (let i = 0; i < numPuffs; i++) {
                    const puffGeometry = new THREE.SphereGeometry(8 + Math.random() * 6, 8, 6);
                    const puffMaterial = new THREE.MeshLambertMaterial({
                        color: 0xffffff,
                        transparent: true,
                        opacity: this.opacity * (0.6 + Math.random() * 0.4)
                    });
                    const puff = new THREE.Mesh(puffGeometry, puffMaterial);
                    
                    puff.position.set(
                        (Math.random() - 0.5) * 25,
                        (Math.random() - 0.5) * 8,
                        (Math.random() - 0.5) * 25
                    );
                    puff.scale.setScalar(0.7 + Math.random() * 0.6);
                    
                    group.add(puff);
                }
                
                group.position.copy(this.position);
                group.scale.setScalar(this.scale);
                scene.add(group);
                this.mesh = group;
            }
            
            update(deltaTime) {
                this.age += deltaTime;
                
                // Move clouds slowly
                this.position.add(this.velocity.clone().multiplyScalar(deltaTime * 10));
                this.mesh.position.copy(this.position);
                
                // Gentle morphing
                this.mesh.children.forEach((puff, i) => {
                    puff.rotation.y += 0.002;
                    puff.position.y += Math.sin(this.age * 0.001 + i) * 0.02;
                });
                
                // Fade based on season and time
                const timeOpacity = Math.max(0.1, Math.sin((timeOfDay - 6) * Math.PI / 12));
                const targetOpacity = this.opacity * timeOpacity;
                
                this.mesh.children.forEach(puff => {
                    puff.material.opacity = targetOpacity * (0.6 + Math.random() * 0.4);
                });
                
                // Remove if too far
                if (Math.abs(this.position.x - camera.position.x) > 2000 || Math.abs(this.position.z - camera.position.z) > 2000) {
                    scene.remove(this.mesh);
                    return false;
                }
                return true;
            }
        }
        
        // JavaScript Port of Cognitive Bell Autoencoder - The "World Mind"
        class CognitiveBellSystem {
            constructor(grid_size = 64) {
                this.grid_size = grid_size;
                this.laplacian_kernel = [
                    [0, 1, 0],
                    [1, -4, 1],
                    [0, 1, 0]
                ];
                
                // Initialize 2D arrays
                this.phi = Array.from({length: grid_size}, () => new Array(grid_size).fill(0));
                this.phi_prev = this.clone2D(this.phi);
                this.phi_dot = this.clone2D(this.phi);
                this.emergent_particles = [];
                
                // Scouts
                this.num_scouts = 200;
                this.scout_pos = Array.from({length: this.num_scouts}, () => [Math.random() * grid_size, Math.random() * grid_size]);
                this.scout_vel = Array.from({length: this.num_scouts}, () => [0, 0]);
                this.scout_weights = new Array(this.num_scouts).fill(0.1);
                
                // World data
                this.world_data = Array.from({length: grid_size}, () => new Array(grid_size).fill(0));
                
                // Reconstruction
                this.reconstruction = this.clone2D(this.world_data);
                
                // Parameters
                this.DT = 0.02;
                this.SCOUT_DAMPING = 0.90;
                this.ATTENTION_FORCE = 0.8;
                this.EXPLORATION_NOISE = 0.15;
                this.FEATURE_SENSITIVITY = 1.5;
                this.BASE_C_WAVE_SQ = 1.0;
                this.A_COEFF = 0.15;
                this.B_COEFF = 0.1;
                this.DAMPING = 0.02;
                this.TENSION_FACTOR = 5.0;
                this.BIHARMONIC_GAMMA = 0.02;
                this.PARTICLE_THRESHOLD = 0.5;
                this.SCOUT_STRIKE_STRENGTH = 0.5;
            }
            
            clone2D(arr) {
                return arr.map(row => row.slice());
            }
            
            convolve2d(field, kernel) {
                const output = Array.from({length: this.grid_size}, () => new Array(this.grid_size).fill(0));
                for (let y = 0; y < this.grid_size; y++) {
                    for (let x = 0; x < this.grid_size; x++) {
                        let sum = 0;
                        for (let ky = 0; ky < 3; ky++) {
                            for (let kx = 0; kx < 3; kx++) {
                                const ny = (y + ky - 1 + this.grid_size) % this.grid_size;
                                const nx = (x + kx - 1 + this.grid_size) % this.grid_size;
                                sum += field[ny][nx] * kernel[ky][kx];
                            }
                        }
                        output[y][x] = sum;
                    }
                }
                return output;
            }
            
            gradient(field) {
                const grad_x = this.clone2D(field);
                const grad_y = this.clone2D(field);
                for (let y = 0; y < this.grid_size; y++) {
                    for (let x = 0; x < this.grid_size; x++) {
                        grad_x[y][x] = field[y][(x + 1) % this.grid_size] - field[y][(x - 1 + this.grid_size) % this.grid_size];
                        grad_y[y][x] = field[(y + 1) % this.grid_size][x] - field[(y - 1 + this.grid_size) % this.grid_size][x];
                    }
                }
                return [grad_y, grad_x];
            }
            
            update_scouts() {
                const intensity = this.phi.map(row => row.map(v => v ** 2));
                const [phi_grad_y, phi_grad_x] = this.gradient(intensity);
                
                for (let i = 0; i < this.num_scouts; i++) {
                    let px = Math.floor(this.scout_pos[i][0]);
                    let py = Math.floor(this.scout_pos[i][1]);

                    // FIX: Ensure indices wrap correctly for both positive and negative values
                    px = ((px % this.grid_size) + this.grid_size) % this.grid_size;
                    py = ((py % this.grid_size) + this.grid_size) % this.grid_size;
                    
                    const force_x = phi_grad_x[py][px] * this.ATTENTION_FORCE;
                    const force_y = phi_grad_y[py][px] * this.ATTENTION_FORCE;
                    
                    this.scout_vel[i][0] *= this.SCOUT_DAMPING;
                    this.scout_vel[i][1] *= this.SCOUT_DAMPING;
                    this.scout_vel[i][0] += force_x;
                    this.scout_vel[i][1] += force_y;
                    this.scout_vel[i][0] += (Math.random() - 0.5) * this.EXPLORATION_NOISE * 2;
                    this.scout_vel[i][1] += (Math.random() - 0.5) * this.EXPLORATION_NOISE * 2;
                    
                    // FIX: Let position be continuous, wrap only when accessing grid
                    this.scout_pos[i][0] += this.scout_vel[i][0] * this.DT;
                    this.scout_pos[i][1] += this.scout_vel[i][1] * this.DT;
                }
            }
            
            scouts_sense_world() {
                for (let i = 0; i < this.num_scouts; i++) {
                    let ix = Math.floor(this.scout_pos[i][0]);
                    let iy = Math.floor(this.scout_pos[i][1]);

                    // FIX: Ensure indices wrap correctly for both positive and negative values
                    ix = ((ix % this.grid_size) + this.grid_size) % this.grid_size;
                    iy = ((iy % this.grid_size) + this.grid_size) % this.grid_size;

                    const feature = this.world_data[iy][ix];
                    this.scout_weights[i] += (feature * this.FEATURE_SENSITIVITY - 0.5) * this.DT;
                    this.scout_weights[i] = Math.max(0.01, Math.min(1.0, this.scout_weights[i]));
                }
            }
            
            generate_strike_map() {
                const strike_map = Array.from({length: this.grid_size}, () => new Array(this.grid_size).fill(0));
                for (let i = 0; i < this.num_scouts; i++) {
                    let ix = Math.floor(this.scout_pos[i][0]);
                    let iy = Math.floor(this.scout_pos[i][1]);

                    // FIX: Ensure indices wrap correctly for both positive and negative values
                    ix = ((ix % this.grid_size) + this.grid_size) % this.grid_size;
                    iy = ((iy % this.grid_size) + this.grid_size) % this.grid_size;

                    strike_map[iy][ix] += this.scout_weights[i];
                }
                const blur_kernel = Array.from({length: 3}, () => new Array(3).fill(1/9));
                return this.convolve2d(strike_map, blur_kernel);
            }
            
            update_bell(strike_map) {
                const laplacian = this.convolve2d(this.phi, this.laplacian_kernel);
                const biharm = this.convolve2d(laplacian, this.laplacian_kernel);
                
                const local_c_sq = this.phi.map((row, y) => row.map((v, x) => this.BASE_C_WAVE_SQ / (1.0 + this.TENSION_FACTOR * v**2)));
                
                const wave_force = local_c_sq.map((row, y) => row.map((v, x) => v * laplacian[y][x]));
                
                const potential_force = this.phi.map((row, y) => row.map((v, x) => this.A_COEFF * v - this.B_COEFF * v**3));
                
                const damping_force = this.phi_dot.map((row, y) => row.map((v, x) => -this.DAMPING * v));
                
                const substrate_force = biharm.map((row, y) => row.map((v, x) => -this.BIHARMONIC_GAMMA * v));
                
                const scout_force = strike_map.map((row, y) => row.map((v, x) => v * this.SCOUT_STRIKE_STRENGTH));
                
                const phi_ddot = wave_force.map((row, y) => row.map((v, x) => v + potential_force[y][x] + damping_force[y][x] + substrate_force[y][x] + scout_force[y][x]));
                
                const phi_new = this.phi.map((row, y) => row.map((v, x) => 2 * v - this.phi_prev[y][x] + this.DT**2 * phi_ddot[y][x]));
                
                this.phi_dot = phi_new.map((row, y) => row.map((v, x) => (v - this.phi_prev[y][x]) / (2 * this.DT)));
                
                this.phi_prev = this.clone2D(this.phi);
                
                this.phi = phi_new;
            }
            
            _track_internal_particles() {
                const particles = [];
                for (let y = 0; y < this.grid_size; y++) {
                    for (let x = 0; x < this.grid_size; x++) {
                        const v = this.phi[y][x];
                        if (v > this.PARTICLE_THRESHOLD) {
                            const up = this.phi[(y - 1 + this.grid_size) % this.grid_size][x];
                            const down = this.phi[(y + 1) % this.grid_size][x];
                            const left = this.phi[y][(x - 1 + this.grid_size) % this.grid_size];
                            const right = this.phi[y][(x + 1) % this.grid_size];
                            if (v > up && v > down && v > left && v > right) {
                                particles.push([y, x]);
                            }
                        }
                    }
                }
                this.emergent_particles = particles;
            }
            
            update_reconstruction() {
                this.reconstruction = this.reconstruction.map((row, y) => row.map((v, x) => v * 0.85));
                for (let i = 0; i < this.num_scouts; i++) {
                    let ix = Math.floor(this.scout_pos[i][0]);
                    let iy = Math.floor(this.scout_pos[i][1]);

                    // FIX: Ensure indices wrap correctly for both positive and negative values
                    ix = ((ix % this.grid_size) + this.grid_size) % this.grid_size;
                    iy = ((iy % this.grid_size) + this.grid_size) % this.grid_size;

                    this.reconstruction[iy][ix] += this.scout_weights[i] * 0.2;
                    this.reconstruction[iy][ix] = Math.min(1.0, this.reconstruction[iy][ix]);
                }
            }
            
            step() {
                this.update_scouts();
                this.scouts_sense_world();
                const strike_map = this.generate_strike_map();
                this.update_bell(strike_map);
                this._track_internal_particles();
                this.update_reconstruction();
            }
        }
        
        // Main Crystal Hunt System Class
        class CrystalHuntSystem {
            constructor() {
                this.initialized = false;
                this.sunLight = null;
                this.aiUpdateCounter = 0;
                this.ai = null;
            }
            
            async initialize() {
                if (this.initialized) return;
                
                try {
                    await this.initThreeJS();
                    await this.initPoseDetection();
                    await this.initAudio();
                    this.setupEventListeners();
                    this.ai = new CognitiveBellSystem();
                    this.initPerceptionRenderer();
                    this.initialized = true;
                    console.log('üéÆ Enhanced Crystal Hunt System initialized with World Mind');
                } catch (error) {
                    console.error('Initialization error:', error);
                    throw error;
                }
            }
            
            initPerceptionRenderer() {
                this.perceptionRenderer = new THREE.WebGLRenderer();
                this.perceptionRenderer.setSize(this.ai.grid_size, this.ai.grid_size);
                this.perceptionRenderTarget = new THREE.WebGLRenderTarget(this.ai.grid_size, this.ai.grid_size);
            }
            
            capturePerception() {
                this.perceptionRenderer.setRenderTarget(this.perceptionRenderTarget);
                this.perceptionRenderer.render(scene, camera);
                const pixelBuffer = new Uint8Array(this.ai.grid_size * this.ai.grid_size * 4);
                this.perceptionRenderer.readRenderTargetPixels(this.perceptionRenderTarget, 0, 0, this.ai.grid_size, this.ai.grid_size, pixelBuffer);
                this.perceptionRenderer.setRenderTarget(null);
                
                const perceptionData = Array.from({length: this.ai.grid_size}, () => new Array(this.ai.grid_size).fill(0));
                for (let y = 0; y < this.ai.grid_size; y++) {
                    for (let x = 0; x < this.ai.grid_size; x++) {
                        const idx = (y * this.ai.grid_size + x) * 4;
                        perceptionData[y][x] = (pixelBuffer[idx] + pixelBuffer[idx+1] + pixelBuffer[idx+2]) / (3 * 255); // Grayscale
                    }
                }
                this.ai.world_data = perceptionData;
            }
            
            processAICommands() {
                // Run AI step
                this.ai.step();
                
                // Based on emergent particles (thoughts), execute commands
                const num_thoughts = this.ai.emergent_particles.length;
                if (num_thoughts > 50) { // High activity
                    this.spawnArtifact('legendary');
                } else if (num_thoughts > 30) { // Moderate
                    this.spawnArtifact('rare');
                } else if (Math.random() < 0.05) { // Random
                    this.changeWeather('misty');
                }
            }
            
            spawnArtifact(type) {
                const spawnOffset = new THREE.Vector3(
                    (Math.random() - 0.5) * 200, 
                    0, 
                    (Math.random() - 0.5) * 200
                );
                const spawnPosition = camera.position.clone().add(spawnOffset);
                let { height } = this.getHeightAndBiomeAtPosition(spawnPosition.x, spawnPosition.z);
                spawnPosition.y = height + 15;
                
                console.log(`World Mind spawning ${type} artifact`);
                const artifact = new CivilizationArtifact(spawnPosition, type);
                crystals.push(artifact);
            }
            
            changeWeather(weather) {
                console.log(`World Mind changing weather to ${weather}`);
                if (weather === 'misty') {
                    scene.fog = new THREE.Fog(0xcccccc, 10, 500);
                }
            }
            
            async initThreeJS() {
                scene = new THREE.Scene();
                camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 30000);
                renderer = new THREE.WebGLRenderer({ antialias: true, canvas: document.getElementById('worldCanvas') });
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.shadowMap.enabled = true;
                renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                
                // Dynamic sky based on season and time
                this.updateSkyColor();
                
                // Enhanced lighting system
                const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
                scene.add(ambientLight);
                
                this.sunLight = new THREE.DirectionalLight(0xffffff, 1.2);
                this.sunLight.position.set(1000, 1000, 500);
                this.sunLight.castShadow = true;
                this.sunLight.shadow.mapSize.width = 4096;
                this.sunLight.shadow.mapSize.height = 4096;
                this.sunLight.shadow.camera.near = 0.1;
                this.sunLight.shadow.camera.far = 5000;
                this.sunLight.shadow.camera.left = -1000;
                this.sunLight.shadow.camera.right = 1000;
                this.sunLight.shadow.camera.top = 1000;
                this.sunLight.shadow.camera.bottom = -1000;
                scene.add(this.sunLight);
                
                camera.position.set(0, 150, 0);
                camera.lookAt(0, 100, 100);
                
                console.log('üåç Enhanced 3D World initialized');
            }
            
            updateSkyColor() {
                const seasonColor = seasonColors[currentSeason].sky;
                const timeInfluence = Math.max(0.3, Math.sin((timeOfDay - 6) * Math.PI / 12));
                
                const color = new THREE.Color(seasonColor);
                color.multiplyScalar(timeInfluence);
                scene.background = color;
                scene.fog = new THREE.Fog(color, chunkSize * 2, chunkSize * (viewDistance + 1));
            }
            
            async initAudio() {
                try {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    
                    // Create background music (procedural ambient)
                    this.createBackgroundMusic();
                    
                    console.log('üîä Audio initialized');
                } catch (error) {
                    console.warn('Audio initialization failed:', error);
                }
            }
            
            createBackgroundMusic() {
                if (!audioContext) return;
                
                // Create ambient background music using oscillators
                const playAmbientMusic = () => {
                    if (!musicEnabled) return;
                    
                    const frequencies = [220, 277, 330, 440]; // Am chord
                    
                    frequencies.forEach((freq, i) => {
                        const oscillator = audioContext.createOscillator();
                        const gainNode = audioContext.createGain();
                        const filter = audioContext.createBiquadFilter();
                        
                        oscillator.connect(filter);
                        filter.connect(gainNode);
                        gainNode.connect(audioContext.destination);
                        
                        oscillator.type = 'sine';
                        oscillator.frequency.value = freq;
                        
                        filter.type = 'lowpass';
                        filter.frequency.value = 800 + Math.sin(Date.now() * 0.001 + i) * 200;
                        
                        gainNode.gain.setValueAtTime(0, audioContext.currentTime);
                        gainNode.gain.linearRampToValueAtTime(0.02, audioContext.currentTime + 2);
                        gainNode.gain.setValueAtTime(0.02, audioContext.currentTime + 8);
                        gainNode.gain.linearRampToValueAtTime(0, audioContext.currentTime + 10);
                        
                        oscillator.start();
                        oscillator.stop(audioContext.currentTime + 10);
                    });
                    
                    // Schedule next music loop
                    setTimeout(playAmbientMusic, 8000);
                };
                
                // Start the ambient music
                setTimeout(playAmbientMusic, 1000);
            }
            
            async initPoseDetection() {
                webcamCanvas = document.getElementById('webcamFeed');
                webcamCtx = webcamCanvas.getContext('2d');
                webcamCanvas.width = 200;
                webcamCanvas.height = 130;
                
                if (!window.Pose || !window.Camera) {
                    throw new Error('MediaPipe libraries not loaded');
                }
                
                poseDetector = new window.Pose({
                    locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/pose/${file}`
                });
                
                poseDetector.setOptions({
                    modelComplexity: 1,
                    smoothLandmarks: true,
                    enableSegmentation: false,
                    minDetectionConfidence: 0.5,
                    minTrackingConfidence: 0.5
                });
                
                poseDetector.onResults((results) => this.onPoseResults(results));
                
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: { width: 640, height: 480, facingMode: 'user' }
                });
                
                const videoElement = document.createElement('video');
                videoElement.srcObject = stream;
                videoElement.autoplay = true;
                
                cameraStream = new window.Camera(videoElement, {
                    onFrame: async () => {
                        if (poseDetector && isActive) {
                            await poseDetector.send({ image: videoElement });
                        }
                    },
                    width: 640,
                    height: 480
                });
                
                await cameraStream.start();
                console.log('üìπ Enhanced pose detection initialized');
            }
            
            onPoseResults(results) {
                webcamCtx.clearRect(0, 0, webcamCanvas.width, webcamCanvas.height);
                
                if (results.image) {
                    webcamCtx.drawImage(results.image, 0, 0, webcamCanvas.width, webcamCanvas.height);
                }
                
                if (results.poseLandmarks && window.drawConnectors && window.drawLandmarks) {
                    window.drawConnectors(webcamCtx, results.poseLandmarks, window.POSE_CONNECTIONS, 
                        { color: '#00FF00', lineWidth: 2 });
                    window.drawLandmarks(webcamCtx, results.poseLandmarks, 
                        { color: '#FF0000', lineWidth: 1 });
                }
                
                if (results.poseLandmarks && gameState === 'playing') {
                    this.processPoseForFlight(results.poseLandmarks);
                }
            }
            
            processPoseForFlight(landmarks) {
                const nose = landmarks[0];
                const leftWrist = landmarks[15];
                const rightWrist = landmarks[16];
                const leftShoulder = landmarks[11];
                const rightShoulder = landmarks[12];
                
                // Head control for camera tilt
                if (nose && leftShoulder && rightShoulder) {
                    const shoulderCenter = {
                        x: (leftShoulder.x + rightShoulder.x) / 2,
                        y: (leftShoulder.y + rightShoulder.y) / 2
                    };
                    
                    const headTilt = {
                        x: (nose.x - shoulderCenter.x) * 2,
                        y: (nose.y - shoulderCenter.y) * 2
                    };
                    
                    cameraRotation.z = headTilt.x * 0.4;
                    cameraRotation.x = headTilt.y * 0.2;
                }
                
                // Right hand control (direction)
                if (rightWrist && rightShoulder && rightWrist.visibility > 0.3) {
                    const rightHandOffset = {
                        x: (rightWrist.x - rightShoulder.x) * 4,
                        y: (rightWrist.y - rightShoulder.y) * 4
                    };
                    
                    flightDirection.x = Math.max(-1, Math.min(1, rightHandOffset.x * 0.9));
                    flightDirection.y = Math.max(-1, Math.min(1, -rightHandOffset.y * 0.6));
                } else {
                    flightDirection.x *= 0.92;
                    flightDirection.y *= 0.92;
                }
                
                // Left hand control (speed)
                if (leftWrist && leftWrist.visibility > 0.3) {
                    const handY = leftWrist.y;
                    const invertedY = 1 - handY;
                    
                    let speedControl = invertedY;
                    if (invertedY > 0.5) {
                        speedControl = (invertedY - 0.5) * 2;
                    } else {
                        speedControl = 0;
                    }
                    
                    flightSpeed = speedControl * 280; // Enhanced max speed
                } else {
                    flightSpeed *= 0.93;
                }
            }

            getBiome(x, z) {
                // Use a very low frequency noise to determine the biome
                const biomeNoise = noise.noise2D(x * 0.0002, z * 0.0002);

                if (biomeNoise < -0.2) {
                    return 'ocean';
                } else if (biomeNoise > 0.3) {
                    return 'desert';
                } else {
                    return 'land';
                }
            }
            
            generateTerrain(chunkX, chunkZ) {
                const geometry = new THREE.PlaneGeometry(chunkSize, chunkSize, 64, 64); // Reduced segments for performance
                const vertices = geometry.attributes.position.array;
                const colors = [];
                
                for (let i = 0; i < vertices.length; i += 3) {
                    const x = chunkX * chunkSize + vertices[i];
                    const z = chunkZ * chunkSize + vertices[i + 1];

                    let { height, color } = this.getHeightAndBiomeAtPosition(x, z);
                    
                    vertices[i + 2] = height;
                    colors.push(color.r, color.g, color.b);
                }
                
                geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
                geometry.computeVertexNormals();
                
                const material = new THREE.MeshLambertMaterial({ 
                    vertexColors: true,
                    side: THREE.DoubleSide
                });
                
                const mesh = new THREE.Mesh(geometry, material);
                mesh.rotation.x = -Math.PI / 2;
                mesh.position.set(chunkX * chunkSize, 0, chunkZ * chunkSize);
                mesh.receiveShadow = true;
                mesh.castShadow = false;
                
                scene.add(mesh);
                return mesh;
            }

            spawnCity(cityX, cityZ) {
                const numBuildings = 5 + Math.floor(Math.random() * 10);
                citiesFound++;
                for (let i = 0; i < numBuildings; i++) {
                    const buildingX = cityX + (Math.random() - 0.5) * 150;
                    const buildingZ = cityZ + (Math.random() - 0.5) * 150;
                    const { height: buildingY } = this.getHeightAndBiomeAtPosition(buildingX, buildingZ);

                    // Ensure it spawns on the ground
                    if (buildingY > 0) {
                       const structure = new CivilizationStructure(buildingX, buildingY, buildingZ, 'building');
                       civilizations.push(structure);
                    }
                }
                // Add a pyramid to the city center
                const { height: pyramidY } = this.getHeightAndBiomeAtPosition(cityX, cityZ);
                if (pyramidY > 0) {
                    const pyramid = new CivilizationStructure(cityX, pyramidY, cityZ, 'pyramid');
                    civilizations.push(pyramid);
                }
            }

            addContentToChunk(chunkX, chunkZ) {
                const chunkWorldX = chunkX * chunkSize;
                const chunkWorldZ = chunkZ * chunkSize;
                const biome = this.getBiome(chunkWorldX, chunkWorldZ);

                switch (biome) {
                    case 'desert':
                        // High chance of spawning a city in a desert chunk
                        if (Math.random() < 0.25) {
                           this.spawnCity(chunkWorldX + (Math.random() - 0.5) * chunkSize * 0.5, chunkWorldZ + (Math.random() - 0.5) * chunkSize * 0.5);
                        }
                        // Add cacti
                        for (let i = 0; i < 20; i++) {
                            const x = chunkWorldX + (Math.random() - 0.5) * chunkSize;
                            const z = chunkWorldZ + (Math.random() - 0.5) * chunkSize;
                            const { height } = this.getHeightAndBiomeAtPosition(x, z);
                            if (height > 5) {
                                this.createCactus(x, height, z);
                            }
                        }
                        break;
                    
                    case 'land':
                        // Add enhanced trees with seasonal variation
                        for (let i = 0; i < 35; i++) {
                            const x = chunkWorldX + (Math.random() - 0.5) * chunkSize;
                            const z = chunkWorldZ + (Math.random() - 0.5) * chunkSize;
                            const { height } = this.getHeightAndBiomeAtPosition(x, z);
                            if (height > 8 && height < 150) {
                                this.createEnhancedTree(x, height, z);
                            }
                        }
                        break;

                    case 'ocean':
                        // Ocean is mostly empty on the surface
                        break;
                }

                // Add crystals to all land-based biomes
                if (biome !== 'ocean') {
                    const numCrystals = 4 + Math.floor(Math.random() * 6);
                    for (let i = 0; i < numCrystals; i++) {
                        const x = chunkWorldX + (Math.random() - 0.5) * chunkSize;
                        const z = chunkWorldZ + (Math.random() - 0.5) * chunkSize;
                        const { height } = this.getHeightAndBiomeAtPosition(x, z);
                        
                        if (height > 5) {
                            const crystalY = height + 8; // Float above ground
                            const position = new THREE.Vector3(x, crystalY, z);
                            let type = 'relic';
                            if (Math.random() < 0.05) type = 'legendary';
                            else if (Math.random() < 0.15) type = 'rare';
                            crystals.push(new CivilizationArtifact(position, type));
                        }
                    }
                }

                // Add volumetric clouds and attractors everywhere
                if (Math.random() < 0.4) {
                    volumetricClouds.push(new VolumetricCloud(
                        chunkWorldX + (Math.random() - 0.5) * chunkSize,
                        120 + Math.random() * 80,
                        chunkWorldZ + (Math.random() - 0.5) * chunkSize
                    ));
                }
                if (Math.random() < 0.15) {
                    infiniteAttractors.push(new InfiniteAttractor());
                }
            }
            
            getHeightAndBiomeAtPosition(x, z) {
                const biome = this.getBiome(x, z);
                let height = 0;
                let color = new THREE.Color();
                
                switch (biome) {
                    case 'ocean':
                        height = -40 + noise.noise2D(x * 0.005, z * 0.005) * 10;
                        color.setRGB(0.1, 0.2, 0.4); // Deep blue
                        break;

                    case 'desert':
                        height = 5 + noise.noise2D(x * 0.01, z * 0.01) * 3 + noise.noise2D(x * 0.05, z * 0.05) * 2; // Sandy dunes
                        color.setHex(0xC2B280); // Sand color
                        color.multiplyScalar(0.9 + Math.random() * 0.1);
                        break;

                    case 'land':
                    default:
                        // Mountainous terrain logic
                        height += noise.noise2D(x * 0.003, z * 0.003) * 200;
                        height += noise.noise2D(x * 0.008, z * 0.008) * 80;
                        height += noise.noise2D(x * 0.02, z * 0.02) * 40;
                        height += noise.noise2D(x * 0.1, z * 0.1) * 5;

                        // Coloring for land
                        if (height < 5) { // Beach transition
                            color.setHex(0xD2B48C); // Tan
                        } else if (height < 80) {
                            const grassColor = seasonColors[currentSeason].foliage;
                            color.setHex(grassColor);
                            color.multiplyScalar(0.6 + Math.random() * 0.2);
                        } else if (height < 150) {
                            color.setRGB(0.5, 0.45, 0.4); // Mountains
                        } else {
                            color.setRGB(0.9, 0.9, 0.9); // Snow peaks
                        }
                        break;
                }
                return { height, biome, color };
            }
            
            createCactus(x, y, z) {
                const group = new THREE.Group();
                group.position.set(x, y, z);

                const cactusMaterial = new THREE.MeshLambertMaterial({ color: 0x2E8B57 });
                
                // Main trunk
                const trunkHeight = 4 + Math.random() * 6;
                const trunkGeometry = new THREE.CylinderGeometry(0.5, 0.5, trunkHeight, 8);
                const trunk = new THREE.Mesh(trunkGeometry, cactusMaterial);
                trunk.position.y = trunkHeight / 2;
                trunk.castShadow = true;
                group.add(trunk);

                // Arms
                if (Math.random() > 0.3) {
                    const armHeight = 2 + Math.random() * 2;
                    const armGeometry = new THREE.CylinderGeometry(0.4, 0.4, armHeight, 8);
                    const arm = new THREE.Mesh(armGeometry, cactusMaterial);
                    arm.position.y = trunkHeight * 0.6;
                    arm.position.x = 0.5;
                    arm.rotation.z = -Math.PI / 2;
                    group.add(arm);
                }

                scene.add(group);
                cacti.push(group);
            }

            createEnhancedTree(x, y, z) {
                const group = new THREE.Group();
                group.position.set(x, y, z);
                
                // Add collection properties
                group.userData = {
                    isTree: true,
                    collected: false,
                    originalPosition: new THREE.Vector3(x, y, z)
                };
                
                // Trunk with seasonal variation
                const trunkHeight = 18 + Math.random() * 12;
                const trunkRadius = 1.2 + Math.random() * 0.8;
                const trunkGeometry = new THREE.CylinderGeometry(trunkRadius * 0.8, trunkRadius, trunkHeight, 8);
                const trunkMaterial = new THREE.MeshLambertMaterial({ color: 0x4a3c28 });
                const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
                trunk.position.y = trunkHeight / 2;
                trunk.castShadow = true;
                group.add(trunk);
                
                // Foliage with seasonal colors
                const foliageSize = 8 + Math.random() * 6;
                const foliageGeometry = new THREE.SphereGeometry(foliageSize, 12, 8);
                const seasonalColor = seasonColors[currentSeason].foliage;
                const foliageMaterial = new THREE.MeshLambertMaterial({ 
                    color: new THREE.Color(seasonalColor).multiplyScalar(0.8 + Math.random() * 0.4)
                });
                const foliage = new THREE.Mesh(foliageGeometry, foliageMaterial);
                foliage.position.y = trunkHeight + foliageSize * 0.3;
                foliage.castShadow = true;
                foliage.receiveShadow = true;
                group.add(foliage);
                
                // Add some randomness to tree shape
                if (Math.random() < 0.3) {
                    const secondFoliage = new THREE.Mesh(
                        new THREE.SphereGeometry(foliageSize * 0.7, 10, 6),
                        foliageMaterial
                    );
                    secondFoliage.position.y = trunkHeight + foliageSize * 0.8;
                    secondFoliage.position.x = (Math.random() - 0.5) * 4;
                    secondFoliage.position.z = (Math.random() - 0.5) * 4;
                    secondFoliage.castShadow = true;
                    group.add(secondFoliage);
                }
                
                scene.add(group);
                trees.push(group);
            }
            
            updateChunks() {
                const chunkX = Math.floor(camera.position.x / chunkSize);
                const chunkZ = Math.floor(camera.position.z / chunkSize);
                
                for (let dx = -viewDistance; dx <= viewDistance; dx++) {
                    for (let dz = -viewDistance; dz <= viewDistance; dz++) {
                        const key = `${chunkX + dx},${chunkZ + dz}`;
                        if (!chunks.has(key)) {
                            const mesh = this.generateTerrain(chunkX + dx, chunkZ + dz);
                            chunks.set(key, { mesh });
                            this.addContentToChunk(chunkX + dx, chunkZ + dz);
                            chunksLoaded++;
                        }
                    }
                }
                
                // Remove distant chunks
                chunks.forEach((chunkData, key) => {
                    const [mx, mz] = key.split(',').map(Number);
                    if (Math.abs(mx - chunkX) > viewDistance + 1 || Math.abs(mz - chunkZ) > viewDistance + 1) {
                        scene.remove(chunkData.mesh);
                        chunks.delete(key);
                        // NOTE: For a full game, you would also remove trees, cacti, etc. associated with this chunk
                    }
                });
            }
            
            updateFlight(deltaTime) {
                if (gameState !== 'playing') return;
                
                const baseSpeed = 1200;
                const gestureSpeed = flightSpeed * 18;
                const totalSpeed = baseSpeed + gestureSpeed;
                const moveSpeed = totalSpeed * deltaTime * 0.04;
                
                const forward = new THREE.Vector3(0, 0, -1);
                forward.applyQuaternion(camera.quaternion);
                
                const right = new THREE.Vector3(1, 0, 0);
                right.applyQuaternion(camera.quaternion);
                
                const up = new THREE.Vector3(0, 1, 0);
                
                const forwardMovement = forward.clone().multiplyScalar(moveSpeed);
                const lateralMovement = right.clone().multiplyScalar(flightDirection.x * moveSpeed * 2.5);
                const verticalMovement = up.clone().multiplyScalar(flightDirection.y * moveSpeed * 1.8);
                
                camera.position.add(forwardMovement);
                camera.position.add(lateralMovement);
                camera.position.add(verticalMovement);
                
                // Ground collision and altitude constraints
                const { height: groundHeight, biome } = this.getHeightAndBiomeAtPosition(camera.position.x, camera.position.z);
                const minAltitude = (biome === 'ocean' ? 10 : 25) + groundHeight;
                const maxAltitude = 800 + groundHeight;
                
                if (camera.position.y < minAltitude) {
                    camera.position.y = minAltitude;
                } else if (camera.position.y > maxAltitude) {
                    camera.position.y = maxAltitude;
                }
                
                altitude = camera.position.y - groundHeight;


                // Enhanced camera rotation
                const targetRotationX = cameraRotation.x * 0.25;
                const targetRotationZ = cameraRotation.z * 0.4;
                
                camera.rotation.x += (targetRotationX - camera.rotation.x) * 0.08;
                camera.rotation.z += (targetRotationZ - camera.rotation.z) * 0.08;
                
                const turnSpeed = flightDirection.x * 0.025;
                camera.rotation.y -= turnSpeed; // Inverted for more intuitive turning
                
                // Update current biome based on position
                this.updateCurrentBiome();
            }
            
            updateCurrentBiome() {
                const { biome, height } = this.getHeightAndBiomeAtPosition(camera.position.x, camera.position.z);
                let biomeName = "Unknown";
                switch(biome) {
                    case 'ocean': biomeName = 'Deep Ocean'; break;
                    case 'desert': biomeName = 'Endless Dunes'; break;
                    case 'land': biomeName = height > 80 ? 'Highlands' : 'Temperate Forest'; break;
                }
                
                document.getElementById('currentBiome').textContent = biomeName;
                document.getElementById('currentAltitude').textContent = Math.round(altitude) + 'm';
            }
            
            updateTimeAndSeason(deltaTime) {
                // Update time of day
                timeOfDay += deltaTime * timeSpeed;
                if (timeOfDay >= 24) {
                    timeOfDay -= 24;
                    // Season progression (very slow)
                    if (Math.random() < 0.001) {
                        this.advanceSeason();
                    }
                }
                
                // Update sun position
                const sunAngle = ((timeOfDay - 6) / 12) * Math.PI;
                const sunHeight = Math.sin(sunAngle) * 1000;
                const sunDistance = Math.cos(sunAngle) * 1000;
                
                this.sunLight.position.set(sunDistance, Math.max(100, sunHeight), 500);
                this.sunLight.intensity = Math.max(0.2, Math.sin(sunAngle));
                
                // Update sky color
                this.updateSkyColor();
                
                // Update time display
                const hours = Math.floor(timeOfDay);
                const minutes = Math.floor((timeOfDay % 1) * 60);
                let timeString = hours + ':' + minutes.toString().padStart(2, '0');
                
                let timeLabel = 'Night';
                if (hours >= 5 && hours < 8) timeLabel = 'Dawn';
                else if (hours >= 8 && hours < 17) timeLabel = 'Day';
                else if (hours >= 17 && hours < 20) timeLabel = 'Dusk';
                
                document.getElementById('currentTime').textContent = timeLabel + ' (' + timeString + ')';
                document.getElementById('currentSeason').textContent = currentSeason.charAt(0).toUpperCase() + currentSeason.slice(1);
                
                // Weather effects
                this.updateWeather();
            }
            
            advanceSeason() {
                const seasons = ['spring', 'summer', 'autumn', 'winter'];
                const currentIndex = seasons.indexOf(currentSeason);
                currentSeason = seasons[(currentIndex + 1) % seasons.length];
                
                // Update tree colors
                trees.forEach(tree => {
                    const foliage = tree.children.find(child => child.geometry.type === 'SphereGeometry');
                    if (foliage) {
                        const seasonColor = seasonColors[currentSeason].foliage;
                        foliage.material.color.setHex(seasonColor);
                        foliage.material.color.multiplyScalar(0.8 + Math.random() * 0.4);
                    }
                });
                
                console.log(`üçÇ Season changed to ${currentSeason}`);
            }
            
            updateWeather() {
                const weatherTypes = ['Clear', 'Partly Cloudy', 'Cloudy', 'Misty'];
                const cloudDensity = volumetricClouds.length;
                
                let weather = 'Clear';
                if (cloudDensity > 15) weather = 'Cloudy';
                else if (cloudDensity > 8) weather = 'Partly Cloudy';
                else if (timeOfDay < 7 || timeOfDay > 19) weather = 'Misty';
                
                document.getElementById('currentWeather').textContent = weather;
            }
            
            setupEventListeners() {
                window.addEventListener('resize', () => {
                    camera.aspect = window.innerWidth / window.innerHeight;
                    camera.updateProjectionMatrix();
                    renderer.setSize(window.innerWidth, window.innerHeight);
                });
            }
            
            start() {
                isActive = true;
                this.updateChunks();
                this.animate();
            }
            
            animate() {
                if (!isActive) return;
                
                const deltaTime = 0.016;
                
                requestAnimationFrame(() => this.animate());

                this.updateFlight(deltaTime);
                this.updateChunks();
                this.updateTimeAndSeason(deltaTime);
                
                // Update crystals/artifacts
                crystals.forEach(crystal => crystal.update(deltaTime));
                
                // Update infinite attractors
                infiniteAttractors.forEach((attractor, index) => {
                    attractor.update(deltaTime);
                    if (attractor.caught) {
                        infiniteAttractors.splice(index, 1);
                    }
                });
                
                // Update volumetric clouds
                volumetricClouds.forEach((cloud, index) => {
                    if (!cloud.update(deltaTime)) {
                        volumetricClouds.splice(index, 1);
                    }
                });
                
                // Remove collected crystals
                for (let i = crystals.length - 1; i >= 0; i--) {
                    if (crystals[i].collected) {
                        crystals.splice(i, 1);
                    }
                }
                
                // Update game logic
                if (gameState === 'playing') {
                    updateGameLogic(deltaTime);
                }
                
                // World Mind (AI) integration
                this.aiUpdateCounter++;
                if (this.aiUpdateCounter > 60) {
                    this.capturePerception();
                    this.processAICommands();
                    this.aiUpdateCounter = 0;
                }
                
                renderer.render(scene, camera);
            }
        }
        
        // Game logic functions
        function updateGameLogic(deltaTime) {
            // Decrease life energy over time
            lifeEnergy -= energyDecayRate * deltaTime;
            
            if (lifeEnergy <= 0) {
                gameOver();
                return;
            }
            
            updateGameUI();
        }
        
        function updateGameUI() {
            document.getElementById('crystalCounter').textContent = `Artifacts: ${crystalsCollected}`;
            document.getElementById('gameScore').textContent = gameScore;
            document.getElementById('energyFill').style.width = `${lifeEnergy}%`;
            document.getElementById('currentSpeed').textContent = `${Math.round(flightSpeed)} km/h`;
            document.getElementById('attractorCount').textContent = attractorsCaught;
            document.getElementById('cityCount').textContent = citiesFound;
            document.getElementById('civsFound').textContent = civilizations.length;
            
            // Energy color changes
            const energyFill = document.getElementById('energyFill');
            if (lifeEnergy > 60) {
                energyFill.style.background = 'linear-gradient(90deg, #00ff00, #80ff00, #ffff00)';
            } else if (lifeEnergy > 30) {
                energyFill.style.background = 'linear-gradient(90deg, #ffff00, #ff8000)';
            } else {
                energyFill.style.background = 'linear-gradient(90deg, #ff0000, #ff4000)';
            }
        }
        
        function gameOver() {
            gameState = 'gameOver';
            isActive = false;
            
            // Update final score
            const totalScore = crystalsCollected * 75 + attractorsCaught * 1000 + citiesFound * 500;
            document.getElementById('finalScore').textContent = 
                `Artifacts: ${crystalsCollected} | Attractors: ${attractorsCaught} | Cities: ${citiesFound} | Score: ${totalScore}`;
            
            document.getElementById('gameOverScreen').classList.remove('hidden');
        }
        
        // Audio control functions
        function toggleMusic() {
            musicEnabled = !musicEnabled;
            const btn = document.getElementById('musicBtn');
            btn.textContent = `üéµ Music: ${musicEnabled ? 'ON' : 'OFF'}`;
            
            if (!musicEnabled && audioContext) {
                // Fade out current sounds
                audioContext.suspend();
            } else if (musicEnabled && audioContext) {
                audioContext.resume();
            }
        }
        
        function toggleSFX() {
            sfxEnabled = !sfxEnabled;
            const btn = document.getElementById('sfxBtn');
            btn.textContent = `üîä SFX: ${sfxEnabled ? 'ON' : 'OFF'}`;
        }
        
        // Global system instance
        let crystalHuntSystem = null;
        
        async function startGame() {
            try {
                document.getElementById('startup').classList.add('hidden');
                document.getElementById('gameInterface').classList.remove('hidden');
                
                // Reset game state
                crystalsCollected = 0;
                lifeEnergy = 100;
                gameScore = 0;
                attractorsCaught = 0;
                citiesFound = 0;
                gameStartTime = Date.now();
                gameState = 'playing';
                flightSpeed = 0;
                flightDirection = { x: 0, y: 0, z: 1 };
                cameraRotation = { x: 0, y: 0, z: 0 };
                currentSeason = 'spring';
                timeOfDay = 6; // Start at dawn
                
                if (!crystalHuntSystem) {
                    crystalHuntSystem = new CrystalHuntSystem();
                    await crystalHuntSystem.initialize();
                }

                // Clear scene before starting
                if (scene) {
                    while(scene.children.length > 0) {
                        scene.remove(scene.children[0]);
                    }
                }
                
                // Reset arrays
                crystals.length = 0;
                infiniteAttractors.length = 0;
                civilizations.length = 0;
                volumetricClouds.length = 0;
                trees.length = 0;
                cacti.length = 0;
                chunks.clear();

                // Re-add lights and re-init scene
                await crystalHuntSystem.initThreeJS();
                camera.position.set(0, 150, 0);

                crystalHuntSystem.start();
                updateGameUI();
                
                console.log('üéÆ Enhanced Civilization Hunt started with World Mind!');
                
            } catch (error) {
                console.error('Failed to start Enhanced Crystal Hunt:', error);
                alert('Failed to initialize Enhanced Crystal Hunt. Please check camera permissions and try again.');
                
                // Return to startup screen on error
                document.getElementById('startup').classList.remove('hidden');
                document.getElementById('gameInterface').classList.add('hidden');
            }
        }
        
        function restartGame() {
            document.getElementById('gameOverScreen').classList.add('hidden');
            startGame();
        }
        
        // Enhanced keyboard controls
        document.addEventListener('keydown', (event) => {
            if (gameState !== 'playing') return;
            
            switch(event.key) {
                case 'w': case 'ArrowUp':
                    flightSpeed = Math.min(280, flightSpeed + 25);
                    break;
                case 's': case 'ArrowDown':
                    flightSpeed = Math.max(0, flightSpeed - 25);
                    break;
                case 'a': case 'ArrowLeft':
                    flightDirection.x = Math.max(-1, flightDirection.x - 0.2);
                    break;
                case 'd': case 'ArrowRight':
                    flightDirection.x = Math.min(1, flightDirection.x + 0.2);
                    break;
                case 'q':
                    cameraRotation.z = Math.max(-0.5, cameraRotation.z - 0.1);
                    break;
                case 'e':
                    cameraRotation.z = Math.min(0.5, cameraRotation.z + 0.1);
                    break;
                case 'r':
                    // Reset position if stuck
                    const { height } = crystalHuntSystem.getHeightAndBiomeAtPosition(camera.position.x, camera.position.z);
                    camera.position.y = height + 50;
                    flightDirection = { x: 0, y: 0, z: 1 };
                    cameraRotation = { x: 0, y: 0, z: 0 };
                    break;
                case 't':
                    // Fast time progression
                    timeOfDay += 2;
                    if (timeOfDay >= 24) timeOfDay -= 24;
                    break;
                case 'c':
                    // Change season manually
                    if (crystalHuntSystem) {
                        crystalHuntSystem.advanceSeason();
                    }
                    break;
                case 'm':
                    // Toggle music
                    toggleMusic();
                    break;
                case 'n':
                    // Toggle SFX
                    toggleSFX();
                    break;
            }
        });
        
        document.addEventListener('keyup', (event) => {
            if (gameState !== 'playing') return;
            
            switch(event.key) {
                case 'a': case 'ArrowLeft':
                case 'd': case 'ArrowRight':
                    flightDirection.x *= 0.8;
                    break;
                case 'q': case 'e':
                    cameraRotation.z *= 0.8;
                    break;
            }
        });
        
        console.log('üèõÔ∏è Fused Crystal Hunt: World Mind Edition ready!');
        console.log('üéÆ Features: Procedural civilizations, volumetric clouds, infinite attractors, seasonal changes, integrated Cognitive Bell AI as World Mind');
        console.log('üåà Hunt for artifacts, catch rainbow attractors, explore ancient cities guided by the World\'s thoughts!');
    </script>
</body>
</html>
