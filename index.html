<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Enhanced Crystal Hunt - Procedural Civilization World</title>
    
    <!-- Three.js and MediaPipe -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/simplex-noise/2.4.0/simplex-noise.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/pose/pose.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: linear-gradient(180deg, #87CEEB 0%, #98FB98 20%, #228B22 100%);
            overflow: hidden;
            font-family: 'Courier New', monospace;
            color: #fff;
        }
        
        .container { width: 100vw; height: 100vh; position: relative; }
        
        .startup {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            z-index: 1000;
            background: rgba(0, 0, 0, 0.9);
            padding: 40px;
            border-radius: 20px;
            border: 3px solid #ff44ff;
            backdrop-filter: blur(15px);
        }
        
        .startup h1 {
            font-size: 3.5em;
            margin-bottom: 20px;
            background: linear-gradient(45deg, #ff44ff, #44ffff, #ffff44, #ff4444);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-shadow: 0 0 30px #ff44ff;
        }
        
        .start-btn {
            background: linear-gradient(45deg, #ff0080, #8000ff, #00ff80, #ff8000);
            border: none;
            padding: 20px 40px;
            font-size: 2em;
            color: white;
            cursor: pointer;
            border-radius: 20px;
            font-family: inherit;
            font-weight: bold;
            transition: all 0.3s;
            margin: 20px;
        }
        
        .start-btn:hover {
            transform: scale(1.1);
            box-shadow: 0 0 50px rgba(255, 68, 255, 0.8);
        }
        
        .hidden { display: none !important; }
        
        #worldCanvas { position: absolute; top: 0; left: 0; z-index: 1; }
        
        #webcamFeed {
            position: absolute;
            bottom: 20px; right: 20px;
            width: 200px; height: 130px;
            border: 3px solid #00ffff;
            border-radius: 15px;
            z-index: 100;
            background: #000;
        }
        
        .game-hud {
            position: absolute;
            top: 20px; left: 20px;
            width: 350px;
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid #ff44ff;
            border-radius: 15px;
            padding: 20px;
            z-index: 100;
            backdrop-filter: blur(10px);
        }
        
        .energy-bar {
            width: 100%;
            height: 20px;
            background: #333;
            border-radius: 10px;
            margin: 10px 0;
            overflow: hidden;
        }
        
        .energy-fill {
            height: 100%;
            background: linear-gradient(90deg, #ff0000, #ffff00, #00ff00);
            width: 100%;
            transition: width 0.3s;
            border-radius: 10px;
        }
        
        .crystal-counter {
            font-size: 1.5em;
            color: #ffff44;
            text-shadow: 0 0 10px #ffff44;
            margin: 10px 0;
        }
        
        .game-over {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            z-index: 2000;
            background: rgba(0, 0, 0, 0.95);
            padding: 40px;
            border-radius: 20px;
            border: 3px solid #ff0000;
            backdrop-filter: blur(15px);
        }
        
        .game-over h2 {
            font-size: 3em;
            color: #ff0000;
            margin-bottom: 20px;
            text-shadow: 0 0 20px #ff0000;
        }
        
        .final-score {
            font-size: 1.5em;
            color: #ffff44;
            margin: 20px 0;
        }
        
        .instruction-hint {
            position: absolute;
            bottom: 160px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            padding: 10px 20px;
            border-radius: 10px;
            border: 1px solid #ffff44;
            z-index: 100;
            font-size: 14px;
            text-align: center;
            animation: fadeInOut 3s infinite;
        }
        
        @keyframes fadeInOut {
            0%, 100% { opacity: 0.7; }
            50% { opacity: 1; }
        }
        
        .crystal-indicator {
            position: absolute;
            pointer-events: none;
            z-index: 200;
            color: #ffff44;
            font-size: 24px;
            font-weight: bold;
            text-shadow: 0 0 10px #ffff44;
            animation: collectAnimation 1s ease-out forwards;
        }
        
        @keyframes collectAnimation {
            0% { transform: scale(1) translateY(0); opacity: 1; }
            100% { transform: scale(2) translateY(-50px); opacity: 0; }
        }
        
        .sound-controls {
            position: absolute;
            top: 20px;
            right: 250px;
            z-index: 100;
        }
        
        .sound-btn {
            background: linear-gradient(45deg, #44ff44, #4444ff);
            border: none;
            color: white;
            padding: 10px 15px;
            border-radius: 10px;
            cursor: pointer;
            font-weight: bold;
            margin: 5px;
        }
        
        .sound-btn:hover {
            transform: scale(1.1);
            box-shadow: 0 0 20px rgba(68, 255, 68, 0.6);
        }

        .world-info {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 10px;
            border: 1px solid #44ff44;
            z-index: 100;
            font-size: 12px;
            max-width: 300px;
        }

        .season-indicator {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.8);
            padding: 10px 20px;
            border-radius: 10px;
            border: 1px solid #ffff44;
            z-index: 100;
            font-size: 14px;
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Startup Screen -->
        <div class="startup" id="startup">
            <h1>üèõÔ∏è Crystal Hunt: Civilization World üåç</h1>
            <p style="font-size: 1.2em; margin: 20px 0; color: #ccc;">
                Explore infinite procedural worlds with ancient civilizations!<br>
                Collect crystals, chase rainbow attractors, discover lost cities!<br>
                üéµ Full soundtrack ‚Ä¢ üèõÔ∏è Procedural civilizations ‚Ä¢ üåà Infinite attractors
            </p>
            <button class="start-btn" onclick="startGame()">üöÄ Begin Civilization Hunt üèõÔ∏è</button>
        </div>
        
        <!-- Game Over Screen -->
        <div class="game-over hidden" id="gameOverScreen">
            <h2>Civilization Explored!</h2>
            <div class="final-score" id="finalScore">Artifacts Found: 0</div>
            <button class="start-btn" onclick="restartGame()">üîÑ Explore New World</button>
        </div>
        
        <!-- Game Interface -->
        <div class="hidden" id="gameInterface">
            <canvas id="worldCanvas"></canvas>
            <canvas id="webcamFeed"></canvas>
            
            <!-- Sound Controls -->
            <div class="sound-controls">
                <button class="sound-btn" id="musicBtn" onclick="toggleMusic()">üéµ Music: ON</button>
                <button class="sound-btn" id="sfxBtn" onclick="toggleSFX()">üîä SFX: ON</button>
            </div>
            
            <!-- Season Indicator -->
            <div class="season-indicator">
                <div>üåø Season: <span id="currentSeason">Spring</span></div>
                <div>üïí Time: <span id="currentTime">Dawn</span></div>
            </div>
            
            <!-- Game HUD -->
            <div class="game-hud">
                <div style="color: #ff44ff; font-size: 16px; font-weight: bold; text-align: center; margin-bottom: 15px;">üèõÔ∏è CIVILIZATION HUNT</div>
                <div class="crystal-counter" id="crystalCounter">Artifacts: 0</div>
                <div style="color: #ff44ff; font-size: 12px;">Life Energy:</div>
                <div class="energy-bar">
                    <div class="energy-fill" id="energyFill"></div>
                </div>
                <div style="display: flex; justify-content: space-between; font-size: 12px; margin-top: 10px;">
                    <span>Score: <span id="gameScore" style="color: #ffff44;">0</span></span>
                    <span>Attractors: <span id="attractorCount" style="color: #ff44ff;">0</span></span>
                </div>
                <div style="display: flex; justify-content: space-between; font-size: 12px; margin-top: 5px;">
                    <span>Cities: <span id="cityCount" style="color: #44ffff;">0</span></span>
                    <span>Speed: <span id="currentSpeed" style="color: #fff;">0 km/h</span></span>
                </div>
            </div>
            
            <!-- World Info -->
            <div class="world-info">
                <h4 style="color: #44ff44;">üåç WORLD STATUS</h4>
                <div>Biome: <span id="currentBiome" style="color: #fff;">Temperate Forest</span></div>
                <div>Civilizations Found: <span id="civsFound" style="color: #ffff44;">0</span></div>
                <div>Weather: <span id="currentWeather" style="color: #87CEEB;">Clear</span></div>
                <div>Altitude: <span id="currentAltitude" style="color: #fff;">150m</span></div>
            </div>
            
            <!-- Instruction Hint -->
            <div class="instruction-hint">
                ‚úã Gesture controls: Left hand for speed ‚Ä¢ Right hand to steer ‚Ä¢ Chase the üåà rainbow attractors!
            </div>
        </div>
    </div>

    <script>
        // Global variables
        let gameState = 'menu';
        let crystalsCollected = 0;
        let lifeEnergy = 100;
        let gameScore = 0;
        let gameStartTime = 0;
        let energyDecayRate = 0.6;
        let crystalEnergyBonus = 25;
        let attractorsCaught = 0;
        let citiesFound = 0;
        
        // Flight and world variables
        let scene, camera, renderer;
        let poseDetector, cameraStream, webcamCanvas, webcamCtx;
        let isActive = false;
        let currentPose = null;
        
        let flightSpeed = 0;
        let flightDirection = { x: 0, y: 0, z: 1 };
        let cameraRotation = { x: 0, y: 0, z: 0 };
        let altitude = 150;
        
        // World generation enhanced
        const noise = new SimplexNoise();
        const chunkSize = 400;
        const viewDistance = 3;
        const chunks = new Map();
        const trees = [];
        const crystals = [];
        const civilizations = [];
        const infiniteAttractors = [];
        const volumetricClouds = [];
        let chunksLoaded = 0;
        
        // Season and time system
        let currentSeason = 'spring';
        let timeOfDay = 6; // Start at dawn
        let timeSpeed = 0.02;
        
        // Audio system
        let audioContext;
        let musicEnabled = true;
        let sfxEnabled = true;
        
        // Season colors
        const seasonColors = {
            spring: { sky: 0x87CEEB, foliage: 0x90EE90 },
            summer: { sky: 0x4169E1, foliage: 0x228B22 },
            autumn: { sky: 0xFFA500, foliage: 0xFF4500 },
            winter: { sky: 0x708090, foliage: 0x2F4F4F }
        };
        
        // Helper function for linear interpolation
        Math.lerp = function(a, b, t) {
            return a + t * (b - a);
        };
        
        // Enhanced Crystal class with civilization artifacts
        class CivilizationArtifact {
            constructor(position, type = 'relic') {
                this.position = position.clone();
                this.originalPosition = position.clone();
                this.type = type;
                this.collected = false;
                this.age = 0;
                this.rotationSpeed = Math.random() * 0.015 + 0.008;
                this.bobSpeed = Math.random() * 0.002 + 0.001;
                this.energy = type === 'legendary' ? 50 : type === 'rare' ? 35 : 25;
                this.frequency = 150 + Math.random() * 600;
                this.culturalValue = Math.random() * 100 + 50;
                
                // Create visual representation based on type
                let geometry, material;
                
                if (type === 'legendary') {
                    geometry = new THREE.DodecahedronGeometry(12, 1);
                    material = new THREE.MeshPhongMaterial({
                        color: 0xffd700,
                        transparent: true,
                        opacity: 0.9,
                        emissive: 0x443300
                    });
                } else if (type === 'rare') {
                    geometry = new THREE.OctahedronGeometry(8, 1);
                    material = new THREE.MeshPhongMaterial({
                        color: 0xffa500,
                        transparent: true,
                        opacity: 0.8,
                        emissive: 0x442200
                    });
                } else {
                    geometry = new THREE.TetrahedronGeometry(6, 0);
                    material = new THREE.MeshPhongMaterial({
                        color: 0x44ffff,
                        transparent: true,
                        opacity: 0.7,
                        emissive: 0x002244
                    });
                }
                
                this.mesh = new THREE.Mesh(geometry, material);
                this.mesh.position.copy(this.position);
                this.mesh.castShadow = true;
                scene.add(this.mesh);
                
                // Enhanced glow effect
                const glowGeometry = new THREE.SphereGeometry(type === 'legendary' ? 18 : type === 'rare' ? 12 : 9, 16, 16);
                const glowMaterial = new THREE.MeshBasicMaterial({
                    color: type === 'legendary' ? 0xffd700 : type === 'rare' ? 0xffa500 : 0x44ffff,
                    transparent: true,
                    opacity: 0.15
                });
                this.glowMesh = new THREE.Mesh(glowGeometry, glowMaterial);
                this.glowMesh.position.copy(this.position);
                scene.add(this.glowMesh);
            }
            
            update(deltaTime) {
                if (this.collected) return;
                
                this.age += deltaTime;
                
                // Enhanced floating animation
                this.mesh.rotation.y += this.rotationSpeed;
                this.mesh.rotation.x += this.rotationSpeed * 0.3;
                this.mesh.rotation.z += this.rotationSpeed * 0.2;
                
                const bobOffset = Math.sin(this.age * this.bobSpeed) * 4;
                const circularMotion = Math.cos(this.age * this.bobSpeed * 0.7) * 2;
                this.mesh.position.y = this.originalPosition.y + bobOffset;
                this.mesh.position.x = this.originalPosition.x + circularMotion;
                this.glowMesh.position.copy(this.mesh.position);
                
                // Enhanced pulsing glow
                const glowPulse = (Math.sin(this.age * 0.003) + 1) * 0.5;
                this.glowMesh.material.opacity = 0.05 + glowPulse * 0.25;
                this.mesh.material.emissiveIntensity = 0.2 + glowPulse * 0.3;
                
                // Check for collection
                const distanceToPlayer = this.mesh.position.distanceTo(camera.position);
                if (distanceToPlayer < 18) {
                    this.collect();
                }
            }
            
            collect() {
                if (this.collected) return;
                
                this.collected = true;
                scene.remove(this.mesh);
                scene.remove(this.glowMesh);
                
                // Update game state based on artifact type
                crystalsCollected++;
                lifeEnergy = Math.min(100, lifeEnergy + this.energy);
                
                if (this.type === 'legendary') {
                    gameScore += 500;
                } else if (this.type === 'rare') {
                    gameScore += 200;
                } else {
                    gameScore += 75;
                }
                
                // Play collection sound
                this.playCollectionSound();
                
                // Show collection indicator
                this.showCollectionEffect();
                
                // Update UI
                updateGameUI();
            }
            
            playCollectionSound() {
                if (!audioContext || !sfxEnabled) return;
                
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                // Different sounds for different artifact types
                let baseFreq = this.frequency;
                if (this.type === 'legendary') baseFreq *= 1.5;
                else if (this.type === 'rare') baseFreq *= 1.2;
                
                oscillator.frequency.setValueAtTime(baseFreq, audioContext.currentTime);
                oscillator.frequency.exponentialRampToValueAtTime(baseFreq * 2.5, audioContext.currentTime + 0.4);
                
                gainNode.gain.setValueAtTime(0.15, audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.4);
                
                oscillator.start();
                oscillator.stop(audioContext.currentTime + 0.4);
            }
            
            showCollectionEffect() {
                const indicator = document.createElement('div');
                indicator.className = 'crystal-indicator';
                
                let text = '+75 ‚ö±Ô∏è';
                if (this.type === 'legendary') text = '+500 üèõÔ∏è LEGENDARY!';
                else if (this.type === 'rare') text = '+200 üíé RARE!';
                
                indicator.textContent = text;
                indicator.style.left = '50%';
                indicator.style.top = '40%';
                document.body.appendChild(indicator);
                
                setTimeout(() => indicator.remove(), 1000);
            }
        }
        
        // Infinite Attractor class (rainbow ball that flies around)
        class InfiniteAttractor {
            constructor() {
                this.position = new THREE.Vector3(
                    (Math.random() - 0.5) * 300,
                    50 + Math.random() * 100,
                    (Math.random() - 0.5) * 300
                );
                this.velocity = new THREE.Vector3(
                    (Math.random() - 0.5) * 2,
                    (Math.random() - 0.5) * 0.5,
                    (Math.random() - 0.5) * 2
                );
                this.age = 0;
                this.caught = false;
                this.trailPoints = [];
                this.maxTrailLength = 20;
                
                // Create rainbow sphere
                const geometry = new THREE.SphereGeometry(3, 16, 12);
                const material = new THREE.MeshBasicMaterial({
                    color: 0xffffff,
                    transparent: true,
                    opacity: 0.8
                });
                this.mesh = new THREE.Mesh(geometry, material);
                this.mesh.position.copy(this.position);
                scene.add(this.mesh);
                
                // Create rainbow trail
                this.createTrail();
            }
            
            createTrail() {
                const trailGeometry = new THREE.BufferGeometry();
                const positions = new Float32Array(this.maxTrailLength * 3);
                const colors = new Float32Array(this.maxTrailLength * 3);
                
                trailGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                trailGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
                
                const trailMaterial = new THREE.LineBasicMaterial({
                    vertexColors: true,
                    transparent: true,
                    opacity: 0.6,
                    linewidth: 3
                });
                
                this.trailMesh = new THREE.Line(trailGeometry, trailMaterial);
                scene.add(this.trailMesh);
            }
            
            update(deltaTime) {
                if (this.caught) return;
                
                this.age += deltaTime;
                
                // Update position with smooth sine wave motion
                this.velocity.x += Math.sin(this.age * 0.01) * 0.02;
                this.velocity.z += Math.cos(this.age * 0.015) * 0.02;
                this.velocity.y += Math.sin(this.age * 0.008) * 0.01;
                
                // Constrain to world bounds and height
                this.velocity.multiplyScalar(0.98);
                this.position.add(this.velocity);
                
                // Keep within bounds (30-200m as requested)
                if (Math.abs(this.position.x) > 200) this.velocity.x *= -1;
                if (Math.abs(this.position.z) > 200) this.velocity.z *= -1;
                if (this.position.y < 30 || this.position.y > 200) this.velocity.y *= -1;
                
                this.mesh.position.copy(this.position);
                
                // Rainbow color cycling
                const hue = (this.age * 0.5) % 1;
                this.mesh.material.color.setHSL(hue, 1, 0.5);
                
                // Update trail
                this.updateTrail();
                
                // Check for collection
                const distanceToPlayer = this.position.distanceTo(camera.position);
                if (distanceToPlayer < 15) {
                    this.catch();
                }
            }
            
            updateTrail() {
                // Add current position to trail
                this.trailPoints.push(this.position.clone());
                if (this.trailPoints.length > this.maxTrailLength) {
                    this.trailPoints.shift();
                }
                
                // Update trail geometry
                const positions = this.trailMesh.geometry.attributes.position.array;
                const colors = this.trailMesh.geometry.attributes.color.array;
                
                for (let i = 0; i < this.trailPoints.length; i++) {
                    const point = this.trailPoints[i];
                    positions[i * 3] = point.x;
                    positions[i * 3 + 1] = point.y;
                    positions[i * 3 + 2] = point.z;
                    
                    // Rainbow colors for trail
                    const hue = ((this.age * 0.5) + i * 0.1) % 1;
                    const color = new THREE.Color().setHSL(hue, 1, 0.5);
                    colors[i * 3] = color.r;
                    colors[i * 3 + 1] = color.g;
                    colors[i * 3 + 2] = color.b;
                }
                
                this.trailMesh.geometry.attributes.position.needsUpdate = true;
                this.trailMesh.geometry.attributes.color.needsUpdate = true;
            }
            
            catch() {
                if (this.caught) return;
                
                this.caught = true;
                scene.remove(this.mesh);
                scene.remove(this.trailMesh);
                
                // Massive score bonus
                attractorsCaught++;
                gameScore += 1000;
                lifeEnergy = Math.min(100, lifeEnergy + 40);
                
                // Play meow sound
                this.playMeowSound();
                
                // Show collection effect
                const indicator = document.createElement('div');
                indicator.className = 'crystal-indicator';
                indicator.textContent = '+1000 üåà RAINBOW CAUGHT!';
                indicator.style.left = '50%';
                indicator.style.top = '40%';
                indicator.style.fontSize = '28px';
                indicator.style.color = '#ff00ff';
                document.body.appendChild(indicator);
                
                setTimeout(() => indicator.remove(), 1500);
                
                updateGameUI();
            }
            
            playMeowSound() {
                if (!audioContext || !sfxEnabled) return;
                
                // Create a meow-like sound using multiple oscillators
                const fundamentalFreq = 200;
                
                for (let i = 0; i < 3; i++) {
                    const oscillator = audioContext.createOscillator();
                    const gainNode = audioContext.createGain();
                    const filter = audioContext.createBiquadFilter();
                    
                    oscillator.connect(filter);
                    filter.connect(gainNode);
                    gainNode.connect(audioContext.destination);
                    
                    oscillator.type = 'triangle';
                    oscillator.frequency.setValueAtTime(fundamentalFreq * (i + 1), audioContext.currentTime);
                    oscillator.frequency.exponentialRampToValueAtTime(fundamentalFreq * (i + 1) * 0.5, audioContext.currentTime + 0.3);
                    
                    filter.type = 'lowpass';
                    filter.frequency.setValueAtTime(2000, audioContext.currentTime);
                    filter.frequency.exponentialRampToValueAtTime(500, audioContext.currentTime + 0.3);
                    
                    gainNode.gain.setValueAtTime(0.1 / (i + 1), audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.3);
                    
                    oscillator.start();
                    oscillator.stop(audioContext.currentTime + 0.3);
                }
            }
        }
        
        // Civilization Structure class
        class CivilizationStructure {
            constructor(x, y, z, type = 'building') {
                this.position = new THREE.Vector3(x, y, z);
                this.type = type;
                this.age = Math.random() * 1000;
                this.culturalSignificance = Math.random();
                
                this.createStructure();
            }
            
            createStructure() {
                const group = new THREE.Group();
                
                // Define local variables from the position
                const x = this.position.x;
                const y = this.position.y;
                const z = this.position.z;
                
                if (this.type === 'temple') {
                    // Create ancient temple
                    const baseGeometry = new THREE.BoxGeometry(15, 8, 15);
                    const baseMaterial = new THREE.MeshLambertMaterial({ color: 0xD2691E });
                    const base = new THREE.Mesh(baseGeometry, baseMaterial);
                    base.position.y = 4;
                    base.castShadow = true;
                    group.add(base);
                    
                    // Add pillars
                    for (let i = 0; i < 8; i++) {
                        const pillarGeometry = new THREE.CylinderGeometry(0.8, 1, 12, 8);
                        const pillarMaterial = new THREE.MeshLambertMaterial({ color: 0xF4A460 });
                        const pillar = new THREE.Mesh(pillarGeometry, pillarMaterial);
                        const angle = (i / 8) * Math.PI * 2;
                        pillar.position.x = Math.cos(angle) * 6;
                        pillar.position.z = Math.sin(angle) * 6;
                        pillar.position.y = 6;
                        pillar.castShadow = true;
                        group.add(pillar);
                    }
                    
                    // Spawn legendary artifact nearby
                    const artifact = new CivilizationArtifact(
                        new THREE.Vector3(x + (Math.random() - 0.5) * 20, y + 5, z + (Math.random() - 0.5) * 20),
                        'legendary'
                    );
                    crystals.push(artifact);
                    
                } else if (this.type === 'pyramid') {
                    // Create pyramid structure
                    const pyramidGeometry = new THREE.ConeGeometry(12, 20, 4);
                    const pyramidMaterial = new THREE.MeshLambertMaterial({ color: 0xCD853F });
                    const pyramid = new THREE.Mesh(pyramidGeometry, pyramidMaterial);
                    pyramid.position.y = 10;
                    pyramid.rotation.y = Math.PI / 4;
                    pyramid.castShadow = true;
                    group.add(pyramid);
                    
                    // Spawn rare artifacts around pyramid
                    for (let i = 0; i < 3; i++) {
                        const artifact = new CivilizationArtifact(
                            new THREE.Vector3(
                                x + (Math.random() - 0.5) * 30,
                                y + 2,
                                z + (Math.random() - 0.5) * 30
                            ),
                            Math.random() < 0.3 ? 'rare' : 'relic'
                        );
                        crystals.push(artifact);
                    }
                    
                } else {
                    // Regular ancient building
                    const buildingHeight = 5 + Math.random() * 8;
                    const buildingGeometry = new THREE.BoxGeometry(
                        3 + Math.random() * 4,
                        buildingHeight,
                        3 + Math.random() * 4
                    );
                    const buildingMaterial = new THREE.MeshLambertMaterial({
                        color: new THREE.Color().setHSL(0.1, 0.3, 0.4 + Math.random() * 0.2)
                    });
                    const building = new THREE.Mesh(buildingGeometry, buildingMaterial);
                    building.position.y = buildingHeight / 2;
                    building.castShadow = true;
                    group.add(building);
                    
                    // Spawn regular artifacts
                    if (Math.random() < 0.4) {
                        const artifact = new CivilizationArtifact(
                            new THREE.Vector3(
                                x + (Math.random() - 0.5) * 15,
                                y + 2,
                                z + (Math.random() - 0.5) * 15
                            ),
                            'relic'
                        );
                        crystals.push(artifact);
                    }
                }
                
                group.position.copy(this.position);
                scene.add(group);
                this.mesh = group;
            }
        }
        
        // Enhanced 3D Cloud system
        class VolumetricCloud {
            constructor(x, y, z) {
                this.position = new THREE.Vector3(x, y, z);
                this.velocity = new THREE.Vector3(
                    (Math.random() - 0.5) * 0.5,
                    0,
                    (Math.random() - 0.5) * 0.3
                );
                this.age = 0;
                this.opacity = 0.3 + Math.random() * 0.4;
                this.scale = 0.8 + Math.random() * 0.6;
                
                this.createCloud();
            }
            
            createCloud() {
                const group = new THREE.Group();
                const numPuffs = 8 + Math.floor(Math.random() * 12);
                
                for (let i = 0; i < numPuffs; i++) {
                    const puffGeometry = new THREE.SphereGeometry(8 + Math.random() * 6, 8, 6);
                    const puffMaterial = new THREE.MeshLambertMaterial({
                        color: 0xffffff,
                        transparent: true,
                        opacity: this.opacity * (0.6 + Math.random() * 0.4)
                    });
                    const puff = new THREE.Mesh(puffGeometry, puffMaterial);
                    
                    puff.position.set(
                        (Math.random() - 0.5) * 25,
                        (Math.random() - 0.5) * 8,
                        (Math.random() - 0.5) * 25
                    );
                    puff.scale.setScalar(0.7 + Math.random() * 0.6);
                    
                    group.add(puff);
                }
                
                group.position.copy(this.position);
                group.scale.setScalar(this.scale);
                scene.add(group);
                this.mesh = group;
            }
            
            update(deltaTime) {
                this.age += deltaTime;
                
                // Move clouds slowly
                this.position.add(this.velocity.clone().multiplyScalar(deltaTime * 10));
                this.mesh.position.copy(this.position);
                
                // Gentle morphing
                this.mesh.children.forEach((puff, i) => {
                    puff.rotation.y += 0.002;
                    puff.position.y += Math.sin(this.age * 0.001 + i) * 0.02;
                });
                
                // Fade based on season and time
                const timeOpacity = Math.max(0.1, Math.sin((timeOfDay - 6) * Math.PI / 12));
                const targetOpacity = this.opacity * timeOpacity;
                
                this.mesh.children.forEach(puff => {
                    puff.material.opacity = targetOpacity * (0.6 + Math.random() * 0.4);
                });
                
                // Remove if too far
                if (Math.abs(this.position.x) > 400 || Math.abs(this.position.z) > 400) {
                    scene.remove(this.mesh);
                    return false;
                }
                return true;
            }
        }
        
        // Main Crystal Hunt System Class
        class CrystalHuntSystem {
            constructor() {
                this.initialized = false;
                this.sunLight = null;
            }
            
            async initialize() {
                if (this.initialized) return;
                
                try {
                    await this.initThreeJS();
                    await this.initPoseDetection();
                    await this.initAudio();
                    this.setupEventListeners();
                    this.initialized = true;
                    console.log('üéÆ Enhanced Crystal Hunt System initialized');
                } catch (error) {
                    console.error('Initialization error:', error);
                    throw error;
                }
            }
            
            async initThreeJS() {
                scene = new THREE.Scene();
                camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 30000);
                renderer = new THREE.WebGLRenderer({ antialias: true, canvas: document.getElementById('worldCanvas') });
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.shadowMap.enabled = true;
                renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                
                // Dynamic sky based on season and time
                this.updateSkyColor();
                
                // Enhanced lighting system
                const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
                scene.add(ambientLight);
                
                this.sunLight = new THREE.DirectionalLight(0xffffff, 1.2);
                this.sunLight.position.set(1000, 1000, 500);
                this.sunLight.castShadow = true;
                this.sunLight.shadow.mapSize.width = 4096;
                this.sunLight.shadow.mapSize.height = 4096;
                this.sunLight.shadow.camera.near = 0.1;
                this.sunLight.shadow.camera.far = 5000;
                this.sunLight.shadow.camera.left = -1000;
                this.sunLight.shadow.camera.right = 1000;
                this.sunLight.shadow.camera.top = 1000;
                this.sunLight.shadow.camera.bottom = -1000;
                scene.add(this.sunLight);
                
                camera.position.set(0, 150, 0);
                camera.lookAt(0, 100, 100);
                
                console.log('üåç Enhanced 3D World initialized');
            }
            
            updateSkyColor() {
                const seasonColor = seasonColors[currentSeason].sky;
                const timeInfluence = Math.max(0.3, Math.sin((timeOfDay - 6) * Math.PI / 12));
                
                const color = new THREE.Color(seasonColor);
                color.multiplyScalar(timeInfluence);
                scene.background = color;
            }
            
            async initAudio() {
                try {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    
                    // Create background music (procedural ambient)
                    this.createBackgroundMusic();
                    
                    console.log('üîä Audio initialized');
                } catch (error) {
                    console.warn('Audio initialization failed:', error);
                }
            }
            
            createBackgroundMusic() {
                if (!audioContext) return;
                
                // Create ambient background music using oscillators
                const playAmbientMusic = () => {
                    if (!musicEnabled) return;
                    
                    const frequencies = [220, 277, 330, 440]; // Am chord
                    
                    frequencies.forEach((freq, i) => {
                        const oscillator = audioContext.createOscillator();
                        const gainNode = audioContext.createGain();
                        const filter = audioContext.createBiquadFilter();
                        
                        oscillator.connect(filter);
                        filter.connect(gainNode);
                        gainNode.connect(audioContext.destination);
                        
                        oscillator.type = 'sine';
                        oscillator.frequency.value = freq;
                        
                        filter.type = 'lowpass';
                        filter.frequency.value = 800 + Math.sin(Date.now() * 0.001 + i) * 200;
                        
                        gainNode.gain.setValueAtTime(0, audioContext.currentTime);
                        gainNode.gain.linearRampToValueAtTime(0.02, audioContext.currentTime + 2);
                        gainNode.gain.setValueAtTime(0.02, audioContext.currentTime + 8);
                        gainNode.gain.linearRampToValueAtTime(0, audioContext.currentTime + 10);
                        
                        oscillator.start();
                        oscillator.stop(audioContext.currentTime + 10);
                    });
                    
                    // Schedule next music loop
                    setTimeout(playAmbientMusic, 8000);
                };
                
                // Start the ambient music
                setTimeout(playAmbientMusic, 1000);
            }
            
            async initPoseDetection() {
                webcamCanvas = document.getElementById('webcamFeed');
                webcamCtx = webcamCanvas.getContext('2d');
                webcamCanvas.width = 200;
                webcamCanvas.height = 130;
                
                if (!window.Pose || !window.Camera) {
                    throw new Error('MediaPipe libraries not loaded');
                }
                
                poseDetector = new window.Pose({
                    locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/pose/${file}`
                });
                
                poseDetector.setOptions({
                    modelComplexity: 1,
                    smoothLandmarks: true,
                    enableSegmentation: false,
                    minDetectionConfidence: 0.5,
                    minTrackingConfidence: 0.5
                });
                
                poseDetector.onResults((results) => this.onPoseResults(results));
                
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: { width: 640, height: 480, facingMode: 'user' }
                });
                
                const videoElement = document.createElement('video');
                videoElement.srcObject = stream;
                videoElement.autoplay = true;
                
                cameraStream = new window.Camera(videoElement, {
                    onFrame: async () => {
                        if (poseDetector && isActive) {
                            await poseDetector.send({ image: videoElement });
                        }
                    },
                    width: 640,
                    height: 480
                });
                
                await cameraStream.start();
                console.log('üìπ Enhanced pose detection initialized');
            }
            
            onPoseResults(results) {
                webcamCtx.clearRect(0, 0, webcamCanvas.width, webcamCanvas.height);
                
                if (results.image) {
                    webcamCtx.drawImage(results.image, 0, 0, webcamCanvas.width, webcamCanvas.height);
                }
                
                if (results.poseLandmarks && window.drawConnectors && window.drawLandmarks) {
                    window.drawConnectors(webcamCtx, results.poseLandmarks, window.POSE_CONNECTIONS, 
                        { color: '#00FF00', lineWidth: 2 });
                    window.drawLandmarks(webcamCtx, results.poseLandmarks, 
                        { color: '#FF0000', lineWidth: 1 });
                }
                
                if (results.poseLandmarks && gameState === 'playing') {
                    this.processPoseForFlight(results.poseLandmarks);
                }
            }
            
            processPoseForFlight(landmarks) {
                const nose = landmarks[0];
                const leftWrist = landmarks[15];
                const rightWrist = landmarks[16];
                const leftShoulder = landmarks[11];
                const rightShoulder = landmarks[12];
                
                // Head control for camera tilt
                if (nose && leftShoulder && rightShoulder) {
                    const shoulderCenter = {
                        x: (leftShoulder.x + rightShoulder.x) / 2,
                        y: (leftShoulder.y + rightShoulder.y) / 2
                    };
                    
                    const headTilt = {
                        x: (nose.x - shoulderCenter.x) * 2,
                        y: (nose.y - shoulderCenter.y) * 2
                    };
                    
                    cameraRotation.z = headTilt.x * 0.4;
                    cameraRotation.x = headTilt.y * 0.2;
                }
                
                // Right hand control (direction)
                if (rightWrist && rightShoulder && rightWrist.visibility > 0.3) {
                    const rightHandOffset = {
                        x: (rightWrist.x - rightShoulder.x) * 4,
                        y: (rightWrist.y - rightShoulder.y) * 4
                    };
                    
                    flightDirection.x = Math.max(-1, Math.min(1, rightHandOffset.x * 0.9));
                    flightDirection.y = Math.max(-1, Math.min(1, -rightHandOffset.y * 0.6));
                } else {
                    flightDirection.x *= 0.92;
                    flightDirection.y *= 0.92;
                }
                
                // Left hand control (speed)
                if (leftWrist && leftWrist.visibility > 0.3) {
                    const handY = leftWrist.y;
                    const invertedY = 1 - handY;
                    
                    let speedControl = invertedY;
                    if (invertedY > 0.5) {
                        speedControl = (invertedY - 0.5) * 2;
                    } else {
                        speedControl = 0;
                    }
                    
                    flightSpeed = speedControl * 280; // Enhanced max speed
                } else {
                    flightSpeed *= 0.93;
                }
            }
            
            generateTerrain(chunkX, chunkZ) {
                const geometry = new THREE.PlaneGeometry(chunkSize, chunkSize, 128, 128);
                const vertices = geometry.attributes.position.array;
                const colors = [];
                
                for (let i = 0; i < vertices.length; i += 3) {
                    const x = chunkX * chunkSize + vertices[i];
                    const z = chunkZ * chunkSize + vertices[i + 1];
                    
                    // Enhanced multi-octave noise with civilization influence
                    let height = 0;
                    height += noise.noise2D(x * 0.003, z * 0.003) * 300;
                    height += noise.noise2D(x * 0.008, z * 0.008) * 120;
                    height += noise.noise2D(x * 0.02, z * 0.02) * 60;
                    height += noise.noise2D(x * 0.05, z * 0.05) * 25;
                    height += noise.noise2D(x * 0.1, z * 0.1) * 8;
                    
                    // Civilization influence - flat areas for structures
                    const civNoise = noise.noise2D(x * 0.001, z * 0.001);
                    if (civNoise > 0.3 && height > -10 && height < 50) {
                        height = Math.lerp(height, 5, 0.7); // Flatten for civilizations
                    }
                    
                    vertices[i + 2] = height;
                    
                    // Enhanced seasonal coloring
                    let color = new THREE.Color();
                    const seasonalModifier = currentSeason === 'winter' ? 0.7 : 
                                           currentSeason === 'autumn' ? 1.2 : 1.0;
                    
                    if (height < -30) {
                        color.setRGB(0.1, 0.15, 0.4); // Deep water
                    } else if (height < -10) {
                        color.setRGB(0.2, 0.3, 0.6); // Shallow water
                    } else if (height < 5) {
                        color.setRGB(0.8, 0.75, 0.6); // Beach
                    } else if (height < 40) {
                        const grassColor = seasonColors[currentSeason].foliage;
                        color.setHex(grassColor);
                        color.multiplyScalar(0.6 + Math.random() * 0.2);
                    } else if (height < 100) {
                        color.setRGB(0.4, 0.35, 0.25); // Hills
                    } else if (height < 200) {
                        color.setRGB(0.5, 0.45, 0.4); // Mountains
                    } else {
                        color.setRGB(0.9, 0.9, 0.9); // Snow peaks
                    }
                    
                    color.multiplyScalar(seasonalModifier);
                    colors.push(color.r, color.g, color.b);
                }
                
                geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
                geometry.computeVertexNormals();
                
                const material = new THREE.MeshLambertMaterial({ 
                    vertexColors: true,
                    side: THREE.DoubleSide
                });
                
                const mesh = new THREE.Mesh(geometry, material);
                mesh.rotation.x = -Math.PI / 2;
                mesh.position.set(chunkX * chunkSize, 0, chunkZ * chunkSize);
                mesh.receiveShadow = true;
                mesh.castShadow = false;
                
                scene.add(mesh);
                return mesh;
            }
            
            addCivilizationsAndCrystals(chunkX, chunkZ) {
                const chunkWorldX = chunkX * chunkSize;
                const chunkWorldZ = chunkZ * chunkSize;
                
                // Add civilizations (less frequent but more impressive)
                const civNoise = noise.noise2D(chunkX * 0.3, chunkZ * 0.3);
                if (civNoise > 0.4 && Math.random() < 0.3) {
                    const civX = chunkWorldX + (Math.random() - 0.5) * chunkSize * 0.6;
                    const civZ = chunkWorldZ + (Math.random() - 0.5) * chunkSize * 0.6;
                    
                    // Determine terrain height
                    let height = this.getHeightAtPosition(civX, civZ);
                    
                    if (height > -5 && height < 60) {
                        // Choose civilization type based on terrain
                        let civType = 'building';
                        if (height < 10 && Math.random() < 0.3) civType = 'temple';
                        else if (height > 20 && Math.random() < 0.2) civType = 'pyramid';
                        
                        const civ = new CivilizationStructure(civX, height, civZ, civType);
                        civilizations.push(civ);
                        citiesFound++;
                    }
                }
                
                // Add crystals in accessible areas (more frequent)
                const numCrystals = 4 + Math.floor(Math.random() * 6);
                for (let i = 0; i < numCrystals; i++) {
                    const x = chunkWorldX + (Math.random() - 0.5) * chunkSize;
                    const z = chunkWorldZ + (Math.random() - 0.5) * chunkSize;
                    
                    let height = this.getHeightAtPosition(x, z);
                    
                    // Place crystals in accessible areas
                    if (height > 5 && height < 250) {
                        const crystalY = height + 8; // Float above ground
                        const position = new THREE.Vector3(x, crystalY, z);
                        
                        // Varied crystal types
                        let type = 'relic';
                        if (Math.random() < 0.05) type = 'legendary';
                        else if (Math.random() < 0.15) type = 'rare';
                        
                        const crystal = new CivilizationArtifact(position, type);
                        crystals.push(crystal);
                    }
                }
                
                // Add enhanced trees with seasonal variation
                for (let i = 0; i < 35; i++) {
                    const x = chunkWorldX + (Math.random() - 0.5) * chunkSize;
                    const z = chunkWorldZ + (Math.random() - 0.5) * chunkSize;
                    
                    let height = this.getHeightAtPosition(x, z);
                    
                    if (height > 8 && height < 150 && Math.random() < 0.6) {
                        this.createEnhancedTree(x, height, z);
                    }
                }
                
                // Add volumetric clouds
                if (Math.random() < 0.4) {
                    const cloud = new VolumetricCloud(
                        chunkWorldX + (Math.random() - 0.5) * chunkSize,
                        120 + Math.random() * 80,
                        chunkWorldZ + (Math.random() - 0.5) * chunkSize
                    );
                    volumetricClouds.push(cloud);
                }
                
                // Spawn infinite attractors occasionally
                if (Math.random() < 0.15) {
                    const attractor = new InfiniteAttractor();
                    infiniteAttractors.push(attractor);
                }
            }
            
            getHeightAtPosition(x, z) {
                // Simplified height calculation for positioning objects
                let height = 0;
                height += noise.noise2D(x * 0.003, z * 0.003) * 300;
                height += noise.noise2D(x * 0.008, z * 0.008) * 120;
                height += noise.noise2D(x * 0.02, z * 0.02) * 60;
                return height;
            }
            
            createEnhancedTree(x, y, z) {
                const group = new THREE.Group();
                group.position.set(x, y, z);
                
                // Add collection properties
                group.userData = {
                    isTree: true,
                    collected: false,
                    originalPosition: new THREE.Vector3(x, y, z)
                };
                
                // Trunk with seasonal variation
                const trunkHeight = 18 + Math.random() * 12;
                const trunkRadius = 1.2 + Math.random() * 0.8;
                const trunkGeometry = new THREE.CylinderGeometry(trunkRadius * 0.8, trunkRadius, trunkHeight, 8);
                const trunkMaterial = new THREE.MeshLambertMaterial({ color: 0x4a3c28 });
                const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
                trunk.position.y = trunkHeight / 2;
                trunk.castShadow = true;
                group.add(trunk);
                
                // Foliage with seasonal colors
                const foliageSize = 8 + Math.random() * 6;
                const foliageGeometry = new THREE.SphereGeometry(foliageSize, 12, 8);
                const seasonalColor = seasonColors[currentSeason].foliage;
                const foliageMaterial = new THREE.MeshLambertMaterial({ 
                    color: new THREE.Color(seasonalColor).multiplyScalar(0.8 + Math.random() * 0.4)
                });
                const foliage = new THREE.Mesh(foliageGeometry, foliageMaterial);
                foliage.position.y = trunkHeight + foliageSize * 0.3;
                foliage.castShadow = true;
                foliage.receiveShadow = true;
                group.add(foliage);
                
                // Add some randomness to tree shape
                if (Math.random() < 0.3) {
                    const secondFoliage = new THREE.Mesh(
                        new THREE.SphereGeometry(foliageSize * 0.7, 10, 6),
                        foliageMaterial
                    );
                    secondFoliage.position.y = trunkHeight + foliageSize * 0.8;
                    secondFoliage.position.x = (Math.random() - 0.5) * 4;
                    secondFoliage.position.z = (Math.random() - 0.5) * 4;
                    secondFoliage.castShadow = true;
                    group.add(secondFoliage);
                }
                
                scene.add(group);
                trees.push(group);
            }
            
            updateChunks() {
                const chunkX = Math.floor(camera.position.x / chunkSize);
                const chunkZ = Math.floor(camera.position.z / chunkSize);
                
                for (let dx = -viewDistance; dx <= viewDistance; dx++) {
                    for (let dz = -viewDistance; dz <= viewDistance; dz++) {
                        const key = `${chunkX + dx},${chunkZ + dz}`;
                        if (!chunks.has(key)) {
                            const mesh = this.generateTerrain(chunkX + dx, chunkZ + dz);
                            chunks.set(key, mesh);
                            this.addCivilizationsAndCrystals(chunkX + dx, chunkZ + dz);
                            chunksLoaded++;
                        }
                    }
                }
                
                // Remove distant chunks
                chunks.forEach((mesh, key) => {
                    const [mx, mz] = key.split(',').map(Number);
                    if (Math.abs(mx - chunkX) > viewDistance + 1 || Math.abs(mz - chunkZ) > viewDistance + 1) {
                        scene.remove(mesh);
                        chunks.delete(key);
                    }
                });
            }
            
            updateFlight(deltaTime) {
                if (gameState !== 'playing') return;
                
                const baseSpeed = 1200;
                const gestureSpeed = flightSpeed * 18;
                const totalSpeed = baseSpeed + gestureSpeed;
                const moveSpeed = totalSpeed * deltaTime * 0.04;
                
                const forward = new THREE.Vector3(0, 0, -1);
                forward.applyQuaternion(camera.quaternion);
                
                const right = new THREE.Vector3(1, 0, 0);
                right.applyQuaternion(camera.quaternion);
                
                const up = new THREE.Vector3(0, 1, 0);
                up.applyQuaternion(camera.quaternion);
                
                const forwardMovement = forward.clone().multiplyScalar(moveSpeed);
                const lateralMovement = right.clone().multiplyScalar(flightDirection.x * moveSpeed * 2.5);
                const verticalMovement = up.clone().multiplyScalar(flightDirection.y * moveSpeed * 1.8);
                
                camera.position.add(forwardMovement);
                camera.position.add(lateralMovement);
                camera.position.add(verticalMovement);
                
                // Enhanced camera rotation
                const targetRotationX = cameraRotation.x * 0.25;
                const targetRotationZ = cameraRotation.z * 0.4;
                
                camera.rotation.x += (targetRotationX - camera.rotation.x) * 0.08;
                camera.rotation.z += (targetRotationZ - camera.rotation.z) * 0.08;
                
                const turnSpeed = flightDirection.x * 0.025;
                camera.rotation.y += turnSpeed;
                
                // Altitude constraints
                const minAltitude = 25;
                const maxAltitude = 800;
                altitude = Math.max(minAltitude, Math.min(maxAltitude, camera.position.y));
                camera.position.y = altitude;
                
                // Update current biome based on position
                this.updateCurrentBiome();
            }
            
            updateCurrentBiome() {
                const height = this.getHeightAtPosition(camera.position.x, camera.position.z);
                let biome = 'Ocean';
                
                if (height < -10) biome = 'Deep Ocean';
                else if (height < 5) biome = 'Coastal';
                else if (height < 40) biome = 'Temperate Forest';
                else if (height < 100) biome = 'Hills';
                else if (height < 200) biome = 'Mountains';
                else biome = 'Alpine';
                
                document.getElementById('currentBiome').textContent = biome;
                document.getElementById('currentAltitude').textContent = Math.round(camera.position.y) + 'm';
            }
            
            updateTimeAndSeason(deltaTime) {
                // Update time of day
                timeOfDay += deltaTime * timeSpeed;
                if (timeOfDay >= 24) {
                    timeOfDay -= 24;
                    // Season progression (very slow)
                    if (Math.random() < 0.001) {
                        this.advanceSeason();
                    }
                }
                
                // Update sun position
                const sunAngle = ((timeOfDay - 6) / 12) * Math.PI;
                const sunHeight = Math.sin(sunAngle) * 1000;
                const sunDistance = Math.cos(sunAngle) * 1000;
                
                this.sunLight.position.set(sunDistance, Math.max(100, sunHeight), 500);
                this.sunLight.intensity = Math.max(0.2, Math.sin(sunAngle));
                
                // Update sky color
                this.updateSkyColor();
                
                // Update time display
                const hours = Math.floor(timeOfDay);
                const minutes = Math.floor((timeOfDay % 1) * 60);
                let timeString = hours + ':' + minutes.toString().padStart(2, '0');
                
                let timeLabel = 'Night';
                if (hours >= 5 && hours < 8) timeLabel = 'Dawn';
                else if (hours >= 8 && hours < 17) timeLabel = 'Day';
                else if (hours >= 17 && hours < 20) timeLabel = 'Dusk';
                
                document.getElementById('currentTime').textContent = timeLabel + ' (' + timeString + ')';
                document.getElementById('currentSeason').textContent = currentSeason.charAt(0).toUpperCase() + currentSeason.slice(1);
                
                // Weather effects
                this.updateWeather();
            }
            
            advanceSeason() {
                const seasons = ['spring', 'summer', 'autumn', 'winter'];
                const currentIndex = seasons.indexOf(currentSeason);
                currentSeason = seasons[(currentIndex + 1) % seasons.length];
                
                // Update tree colors
                trees.forEach(tree => {
                    const foliage = tree.children.find(child => child.geometry.type === 'SphereGeometry');
                    if (foliage) {
                        const seasonColor = seasonColors[currentSeason].foliage;
                        foliage.material.color.setHex(seasonColor);
                        foliage.material.color.multiplyScalar(0.8 + Math.random() * 0.4);
                    }
                });
                
                console.log(`üçÇ Season changed to ${currentSeason}`);
            }
            
            updateWeather() {
                const weatherTypes = ['Clear', 'Partly Cloudy', 'Cloudy', 'Misty'];
                const cloudDensity = volumetricClouds.length;
                
                let weather = 'Clear';
                if (cloudDensity > 15) weather = 'Cloudy';
                else if (cloudDensity > 8) weather = 'Partly Cloudy';
                else if (timeOfDay < 7 || timeOfDay > 19) weather = 'Misty';
                
                document.getElementById('currentWeather').textContent = weather;
            }
            
            setupEventListeners() {
                window.addEventListener('resize', () => {
                    camera.aspect = window.innerWidth / window.innerHeight;
                    camera.updateProjectionMatrix();
                    renderer.setSize(window.innerWidth, window.innerHeight);
                });
            }
            
            start() {
                isActive = true;
                this.updateChunks();
                this.animate();
            }
            
            animate() {
                if (!isActive) return;
                
                const deltaTime = 0.016;
                
                this.updateFlight(deltaTime);
                this.updateChunks();
                this.updateTimeAndSeason(deltaTime);
                
                // Update crystals/artifacts
                crystals.forEach(crystal => crystal.update(deltaTime));
                
                // Check for tree collection
                trees.forEach((tree, index) => {
                    if (!tree.userData.collected) {
                        const distanceToPlayer = tree.position.distanceTo(camera.position);
                        if (distanceToPlayer < 25) { // Larger collection radius for trees
                            tree.userData.collected = true;
                            
                            // Add energy and score
                            lifeEnergy = Math.min(100, lifeEnergy + 4);
                            gameScore += 5;
                            
                            // Visual effect
                            tree.children.forEach(child => {
                                if (child.material) {
                                    child.material.transparent = true;
                                    child.material.opacity = 0.3;
                                }
                            });
                            
                            // Play collection sound
                            if (audioContext && sfxEnabled) {
                                const oscillator = audioContext.createOscillator();
                                const gainNode = audioContext.createGain();
                                
                                oscillator.connect(gainNode);
                                gainNode.connect(audioContext.destination);
                                
                                oscillator.frequency.setValueAtTime(300, audioContext.currentTime);
                                oscillator.frequency.exponentialRampToValueAtTime(600, audioContext.currentTime + 0.2);
                                
                                gainNode.gain.setValueAtTime(0.08, audioContext.currentTime);
                                gainNode.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.2);
                                
                                oscillator.start();
                                oscillator.stop(audioContext.currentTime + 0.2);
                            }
                            
                            // Show collection indicator
                            const indicator = document.createElement('div');
                            indicator.className = 'crystal-indicator';
                            indicator.textContent = '+4 üå≥ ENERGY!';
                            indicator.style.left = '50%';
                            indicator.style.top = '45%';
                            indicator.style.fontSize = '20px';
                            indicator.style.color = '#44ff44';
                            document.body.appendChild(indicator);
                            
                            setTimeout(() => indicator.remove(), 1000);
                            
                            updateGameUI();
                        }
                    }
                });
                
                // Update infinite attractors
                infiniteAttractors.forEach((attractor, index) => {
                    attractor.update(deltaTime);
                    if (attractor.caught) {
                        infiniteAttractors.splice(index, 1);
                    }
                });
                
                // Update volumetric clouds
                volumetricClouds.forEach((cloud, index) => {
                    if (!cloud.update(deltaTime)) {
                        volumetricClouds.splice(index, 1);
                    }
                });
                
                // Spawn new clouds occasionally
                if (Math.random() < 0.002) {
                    const cloud = new VolumetricCloud(
                        camera.position.x + (Math.random() - 0.5) * 800,
                        120 + Math.random() * 80,
                        camera.position.z + (Math.random() - 0.5) * 800
                    );
                    volumetricClouds.push(cloud);
                }
                
                // Spawn new attractors occasionally
                if (Math.random() < 0.001 && infiniteAttractors.length < 3) {
                    const attractor = new InfiniteAttractor();
                    attractor.position.set(
                        camera.position.x + (Math.random() - 0.5) * 400,
                        camera.position.y + (Math.random() - 0.5) * 100,
                        camera.position.z + (Math.random() - 0.5) * 400
                    );
                    infiniteAttractors.push(attractor);
                }
                
                // Remove collected crystals
                for (let i = crystals.length - 1; i >= 0; i--) {
                    if (crystals[i].collected) {
                        crystals.splice(i, 1);
                    }
                }
                
                // Update game logic
                if (gameState === 'playing') {
                    updateGameLogic(deltaTime);
                }
                
                renderer.render(scene, camera);
                requestAnimationFrame(() => this.animate());
            }
        }
        
        // Game logic functions
        function updateGameLogic(deltaTime) {
            // Decrease life energy over time
            lifeEnergy -= energyDecayRate * deltaTime;
            
            if (lifeEnergy <= 0) {
                gameOver();
                return;
            }
            
            updateGameUI();
        }
        
        function updateGameUI() {
            document.getElementById('crystalCounter').textContent = `Artifacts: ${crystalsCollected}`;
            document.getElementById('gameScore').textContent = gameScore;
            document.getElementById('energyFill').style.width = `${lifeEnergy}%`;
            document.getElementById('currentSpeed').textContent = `${Math.round(flightSpeed)} km/h`;
            document.getElementById('attractorCount').textContent = attractorsCaught;
            document.getElementById('cityCount').textContent = citiesFound;
            document.getElementById('civsFound').textContent = civilizations.length;
            
            // Energy color changes
            const energyFill = document.getElementById('energyFill');
            if (lifeEnergy > 60) {
                energyFill.style.background = 'linear-gradient(90deg, #00ff00, #80ff00, #ffff00)';
            } else if (lifeEnergy > 30) {
                energyFill.style.background = 'linear-gradient(90deg, #ffff00, #ff8000)';
            } else {
                energyFill.style.background = 'linear-gradient(90deg, #ff0000, #ff4000)';
            }
        }
        
        function gameOver() {
            gameState = 'gameOver';
            isActive = false;
            
            // Update final score
            const totalScore = crystalsCollected * 75 + attractorsCaught * 1000 + citiesFound * 500;
            document.getElementById('finalScore').textContent = 
                `Artifacts: ${crystalsCollected} | Attractors: ${attractorsCaught} | Cities: ${citiesFound} | Score: ${totalScore}`;
            
            document.getElementById('gameOverScreen').classList.remove('hidden');
        }
        
        // Audio control functions
        function toggleMusic() {
            musicEnabled = !musicEnabled;
            const btn = document.getElementById('musicBtn');
            btn.textContent = `üéµ Music: ${musicEnabled ? 'ON' : 'OFF'}`;
            
            if (!musicEnabled && audioContext) {
                // Fade out current sounds
                audioContext.suspend();
            } else if (musicEnabled && audioContext) {
                audioContext.resume();
            }
        }
        
        function toggleSFX() {
            sfxEnabled = !sfxEnabled;
            const btn = document.getElementById('sfxBtn');
            btn.textContent = `üîä SFX: ${sfxEnabled ? 'ON' : 'OFF'}`;
        }
        
        // Global system instance
        let crystalHuntSystem = null;
        
        async function startGame() {
            try {
                document.getElementById('startup').classList.add('hidden');
                document.getElementById('gameInterface').classList.remove('hidden');
                
                // Reset game state
                crystalsCollected = 0;
                lifeEnergy = 100;
                gameScore = 0;
                attractorsCaught = 0;
                citiesFound = 0;
                gameStartTime = Date.now();
                gameState = 'playing';
                flightSpeed = 0;
                flightDirection = { x: 0, y: 0, z: 1 };
                cameraRotation = { x: 0, y: 0, z: 0 };
                currentSeason = 'spring';
                timeOfDay = 6; // Start at dawn
                
                // Clear existing objects
                crystals.forEach(crystal => {
                    if (crystal.mesh) scene.remove(crystal.mesh);
                    if (crystal.glowMesh) scene.remove(crystal.glowMesh);
                });
                crystals.length = 0;
                infiniteAttractors.length = 0;
                civilizations.length = 0;
                volumetricClouds.length = 0;
                trees.length = 0;
                
                if (!crystalHuntSystem) {
                    crystalHuntSystem = new CrystalHuntSystem();
                    await crystalHuntSystem.initialize();
                }
                
                crystalHuntSystem.start();
                updateGameUI();
                
                console.log('üéÆ Enhanced Civilization Hunt started!');
                
            } catch (error) {
                console.error('Failed to start Enhanced Crystal Hunt:', error);
                alert('Failed to initialize Enhanced Crystal Hunt. Please check camera permissions and try again.');
                
                // Return to startup screen on error
                document.getElementById('startup').classList.remove('hidden');
                document.getElementById('gameInterface').classList.add('hidden');
            }
        }
        
        function restartGame() {
            document.getElementById('gameOverScreen').classList.add('hidden');
            
            // Clear the scene
            if (scene) {
                while(scene.children.length > 0) {
                    scene.remove(scene.children[0]);
                }
            }
            chunks.clear();
            
            startGame();
        }
        
        // Enhanced keyboard controls
        document.addEventListener('keydown', (event) => {
            if (gameState !== 'playing') return;
            
            switch(event.key) {
                case 'w': case 'ArrowUp':
                    flightSpeed = Math.min(280, flightSpeed + 25);
                    break;
                case 's': case 'ArrowDown':
                    flightSpeed = Math.max(0, flightSpeed - 25);
                    break;
                case 'a': case 'ArrowLeft':
                    flightDirection.x = Math.max(-1, flightDirection.x - 0.2);
                    break;
                case 'd': case 'ArrowRight':
                    flightDirection.x = Math.min(1, flightDirection.x + 0.2);
                    break;
                case 'q':
                    cameraRotation.z = Math.max(-0.5, cameraRotation.z - 0.1);
                    break;
                case 'e':
                    cameraRotation.z = Math.min(0.5, cameraRotation.z + 0.1);
                    break;
                case 'r':
                    // Reset position if stuck
                    camera.position.set(0, 150, 0);
                    flightDirection = { x: 0, y: 0, z: 1 };
                    cameraRotation = { x: 0, y: 0, z: 0 };
                    break;
                case 't':
                    // Fast time progression
                    timeOfDay += 2;
                    if (timeOfDay >= 24) timeOfDay -= 24;
                    break;
                case 'c':
                    // Change season manually
                    if (crystalHuntSystem) {
                        crystalHuntSystem.advanceSeason();
                    }
                    break;
                case 'm':
                    // Toggle music
                    toggleMusic();
                    break;
                case 'n':
                    // Toggle SFX
                    toggleSFX();
                    break;
            }
        });
        
        document.addEventListener('keyup', (event) => {
            if (gameState !== 'playing') return;
            
            switch(event.key) {
                case 'a': case 'ArrowLeft':
                case 'd': case 'ArrowRight':
                    flightDirection.x *= 0.8;
                    break;
                case 'q': case 'e':
                    cameraRotation.z *= 0.8;
                    break;
            }
        });
        
        console.log('üèõÔ∏è Enhanced Crystal Hunt: Civilization World ready!');
        console.log('üéÆ Features: Procedural civilizations, volumetric clouds, infinite attractors, seasonal changes');
        console.log('üåà Hunt for artifacts, catch rainbow attractors, explore ancient cities!');
        console.log('üéµ Controls: M=Music, N=SFX, T=Time, C=Season, WASD=Flight, QE=Roll');
    </script>
</body>
</html>
